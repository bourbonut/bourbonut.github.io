[
  {
    "objectID": "posts/involute-spur-gear/index.html",
    "href": "posts/involute-spur-gear/index.html",
    "title": "Spur Tooth Profile",
    "section": "",
    "text": "Involute gears are the most popular power transmission devices. We find them as an essential component for many machines. For instance, epicyclic gear train is a combination of gears which allows to make a reduction in a compact way. Spur gears are the most popular form and the most efficient type of gearing."
  },
  {
    "objectID": "posts/involute-spur-gear/index.html#code",
    "href": "posts/involute-spur-gear/index.html#code",
    "title": "Spur Tooth Profile",
    "section": "Code",
    "text": "Code\nfrom collections import namedtuple\nfrom functools import partial\nfrom manim import * # pip install manim\n\ndef profile(m, z, alpha=radians(20), ka=1, kf=1.25, interference=True):\n    # Parameters\n    ha = m * ka  #                  addendum height\n    hf = m * kf  #                  dedendum height\n    p = pi * m  #                   step\n    rp = pitch_radius(m, z) #       pitch radius\n    ra = rp + ha #                  addendum radius\n    rf = rp - hf #                  dedendum radius\n    rb = base_radius(m, z, alpha) # base radius\n\n    ta = angle_involute(ra, rb) #   addendum angle\n    tp = angle_involute(rp, rb) #   pitch angle\n\n    duplicate = (\n        lambda obj, angle: obj.copy()\n        .apply_matrix(mat3(X, -Y, Z))\n        .rotate_about_origin(angle)\n    )\n    phase = pi / z + 2 * (tp - atan2(tp, 1))\n\n    # Involute\n    side = ParametricFunction(partial(involute, r=rb), t_range=[0, ta])\n\n    # Arc parameters\n    ArcParameters = namedtuple(\"ArcParameters\", [\"center\", \"radius\", \"angle\"])\n    r = 0.5 * (rb - rf)\n    t = -atan2(r, rf + r)\n    arcp = ArcParameters((rf + r) * u(t), r, t)\n    arc = Arc(arcp.radius, -pi + arcp.angle, -pi / 2, arc_center=arcp.center)\n\n    # Joint, top and bottom\n    angle_top = ta - atan2(ta, 1)\n    top = Arc(ra, angle_top, phase - 2 * angle_top)\n    joint = Line(arcp.center + arcp.radius * u(-3 * pi / 2 + arcp.angle), rb * X)\n    M = arcp.center + arcp.radius * u(-pi + arcp.angle)\n    angle_bottom = anglebt(M, u(0.5 * phase)) * 2\n    bottom = Line(M, rotation(-2 * pi / z + angle_bottom) * M)\n\n    # Patches\n    top_dot = Dot(ra * u(angle_top), radius=0.02)\n    side_dot = Dot(rb * X, radius=0.02)\n    point = arcp.center + arcp.radius * u(-3 * pi / 2 + arcp.angle)\n    joint_dot = Dot(point, radius=0.02)\n    bottom_dot = Dot(M, radius=0.02)\n    dots = (top_dot, side_dot, joint_dot, bottom_dot)\n\n    # Duplicated objects\n    duplicated_objs = map(\n        partial(duplicate, angle=phase), (side, arc, joint) + dots\n    )\n\n    return VGroup(\n        side, top, arc, joint, bottom, *duplicated_objs, *dots\n    ).rotate_about_origin(-phase * 0.5)\nNote : for manim, see installation"
  },
  {
    "objectID": "posts/involute-spur-gear/index.html#code-1",
    "href": "posts/involute-spur-gear/index.html#code-1",
    "title": "Spur Tooth Profile",
    "section": "Code",
    "text": "Code\nfrom collections import namedtuple\nfrom functools import partial\nfrom manim import *\n\ndef involute(t, r, t0=0):\n    return r * (u(t - t0) - t * v(t - t0))\n\n\ndef interference_curve(t, r, x, y, t0):\n    return involute(t, r, t0) - x * u(t - t0) + y * v(t - t0)\n\n\ndef derived_involute(t, r, t0):\n    return r * t * u(t - t0)\n\n\ndef derived_interference_curve(t, r, x, y, t0):\n    return derived_involute(t, r, t0) - x * v(t - t0) - y * u(t - t0)\n\n\ndef jacobian_involute(rb, rp, x, y, t0):\n    return lambda t1, t2: mat3(\n        derived_involute(t1, rb, t0), \n        -derived_interference_curve(t2, rp, x, y, t0),\n        Z,\n    )\n\ndef angle_involute(r, rb):\n    return sqrt(r * r / (rb * rb) - 1)\n\ndef profile(m, z, alpha=radians(20), ka=1, kf=1.25, interference=True):\n    # Parameters\n    ha = m * ka  #                  addendum height\n    hf = m * kf  #                  dedendum height\n    p = pi * m  #                   step\n    rp = pitch_radius(m, z) #       pitch radius\n    ra = rp + ha #                  addendum radius\n    rf = rp - hf #                  dedendum radius\n    rb = base_radius(m, z, alpha) # base radius\n\n    ta = angle_involute(ra, rb) #   addendum angle\n    tp = angle_involute(rp, rb) #   pitch angle\n\n    duplicate = (\n        lambda obj, angle: obj.copy()\n        .apply_matrix(mat3(X, -Y, Z))\n        .rotate_about_origin(angle)\n    )\n\n    la = rack.addendum_length(m, alpha, ka)\n    ts = tp - atan2(tp, 1)\n    phase = pi / z + 2 * (tp - atan2(tp, 1))\n    phase_empty = 2 * pi / z - phase\n    angle_top = ta - atan2(ta, 1)\n    tmin = la * 0.5 / rp\n\n    Functions = namedtuple(\"Functions\", [\"involute\", \"interference\"])\n    functions = Functions(\n        partial(involute, r=rb),\n        partial(interference_curve, r=rp, x=ha, y=0.5 * la, t0=phase_empty * 0.5),\n    )\n\n    # Newton method\n    f = lambda t1, t2: functions.involute(t1) - functions.interference(t2)\n    J = jacobian_involute(rb, rp, ha, 0.5 * la, phase_empty * 0.5)\n    # t3 is not used, but exists because 3D vectors\n    t1, t2, t3 = 0.5 * ta, -0.5 * ta, 0\n    for i in range(8):\n        t1, t2, t3 = vec3(t1, t2, t3) - inverse(J(t1, t2)) * f(t1, t2)\n\n    # Involute and interference curve\n    side = ParametricFunction(functions.involute, t_range=[t1, ta])\n    interference = ParametricFunction(functions.interference, t_range=[t2, tmin])\n\n    # Top and bottom\n    top = Arc(ra, angle_top, phase - 2 * angle_top)\n    M = functions.interference(tmin)\n    angle_bottom = anglebt(M, u(0.5 * phase)) * 2\n    bottom = Line(M, rotation(-2 * pi / z + angle_bottom) * M)\n\n    # Patches\n    top_dot = Dot(ra * u(angle_top), radius=0.02)\n    interference_dot = Dot(functions.interference(t2), radius=0.02)\n    involute_dot = Dot(functions.involute(t1), radius=0.02)\n    bottom_dot = Dot(M, radius=0.02)\n    dots = (top_dot, interference_dot, involute_dot, bottom_dot)\n\n    # Duplicated objects\n    duplicated_objs = map(\n        partial(duplicate, angle=phase), (side, interference) + dots\n    )\n\n    return VGroup(\n        side, interference, *duplicated_objs, top, bottom, *dots\n    ).rotate_about_origin(-phase * 0.5)\nAnd the gear profile :\n\n\n\nFigure : Gear profile with interference\n\n\nNote the closest radius to the pinion’s center is greater than the dedendum radius due to the interference curve.\nLet’s see the rack movement now :\n\n\nVideo\nAnimation : Rack moving around the pinion"
  },
  {
    "objectID": "posts/introduction-spiking-nn/index.html",
    "href": "posts/introduction-spiking-nn/index.html",
    "title": "Introduction to Spiking Neural Networks",
    "section": "",
    "text": "In progress"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Benjamin Bourbon",
    "section": "",
    "text": "I’m a young engineer with a specialization in High Performance Computing and Artificial Intelligence.\nI develop currently a CAD library pymadcad with a friend.\nThis blog aims to share some personal work which I find useful."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "In progress",
    "section": "",
    "text": "Introduction to Spiking Neural Networks\n\n\n\n\n\n\n\nartificial intelligence\n\n\n\n\n\n\n\n\n\n\n\nJan 14, 2023\n\n\nBenjamin Bourbon\n\n\n\n\n\n\n  \n\n\n\n\nSpur Tooth Profile\n\n\n\n\n\n\n\nmechanic\n\n\n\n\n\n\n\n\n\n\n\nJan 8, 2023\n\n\nBenjamin Bourbon\n\n\n\n\n\n\nNo matching items"
  }
]