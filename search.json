[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Posts",
    "section": "",
    "text": "Bevel Tooth Profile (Part 3)\n\n\n\nmechanics\n\n\n\n\n\n\n\nBenjamin Bourbon\n\n\nMay 2, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nBevel Tooth Profile (Part 2)\n\n\n\nmechanics\n\n\n\n\n\n\n\nBenjamin Bourbon\n\n\nMay 1, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nBevel Tooth Profile (Part 1)\n\n\n\nmechanics\n\n\n\n\n\n\n\nBenjamin Bourbon\n\n\nApr 29, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIntroduction to Reinforcement Learning\n\n\n\nartificial intelligence\n\n\n\n\n\n\n\nBenjamin Bourbon\n\n\nJan 22, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIntroduction to Federated Learning\n\n\n\nartificial intelligence\n\n\n\n\n\n\n\nBenjamin Bourbon\n\n\nJan 18, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIntroduction to Spiking Neural Networks\n\n\n\nartificial intelligence\n\n\n\n\n\n\n\nBenjamin Bourbon\n\n\nJan 14, 2023\n\n\n\n\n\n\n\n\n\n\n\n\nSpur Tooth Profile\n\n\n\nmechanics\n\n\n\n\n\n\n\nBenjamin Bourbon\n\n\nJan 8, 2023\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "projects/performance/index.html",
    "href": "projects/performance/index.html",
    "title": "Computation of the sum of prime numbers in different languages",
    "section": "",
    "text": "Description\nThe project allows to see the difference of speed of program’s execution between multiple languages with one algorithm which computes the sum of prime numbers. Also, the goal is to use native libraries for each language.\nHere is the source of the algorithm\n\n\nCode\n\n       \nimport math\nfrom time import perf_counter\n\n\ndef chrono(function):\n    def inner(*args):\n        start = perf_counter()\n        result = function(*args)\n        duration = perf_counter() - start\n        print(\"%0.3f x 10e(-3) seconds\" % (duration * 1_000))\n        return result\n\n    return inner\n\n\n# @chrono\ndef P10(n):\n    r = int(n ** 0.5)\n    assert r * r &lt;= n and (r + 1) ** 2 &gt; n\n    V = [n // i for i in range(1, r + 1)]\n    V += list(range(V[-1] - 1, 0, -1))\n    S = {i: i * (i + 1) // 2 - 1 for i in V}\n    for p in range(2, r + 1):\n        if S[p] &gt; S[p - 1]:  # p is prime\n            sp = S[p - 1]  # sum of primes smaller than p\n            p2 = p * p\n            for v in V:\n                if v &lt; p2:\n                    break\n                S[v] -= p * (S[v // p] - sp)\n    return S[n]\n\n\ndef _format(dist, value):\n    return value + \" \" * (dist - len(value))\n\n\nprint(\"Power | Time (µs) | Resultat\")\nprint(\"========================================\")\nfor i in range(1, 9):\n    start = perf_counter()\n    result = P10(10 ** i)\n    duration = int((perf_counter() - start) * 1_000_000)\n    print(_format(5, str(i)) + \" | \" + _format(9, str(duration)) + \" | \" + str(result))\nuse std::collections::HashMap;\nuse std::time::Instant;\n\ntype Dict = HashMap&lt;u64, u128&gt;;\n\nfn get_keys(n: u64, half_size: u64) -&gt; Vec&lt;u64&gt; {\n    // Calculation of keys used in the HashMap\n    let mut v: Vec&lt;u64&gt; = Vec::new();\n    for i in 0..half_size + 1 {\n        v.push(n / (i + 1));\n    }\n    let v_max = v[half_size as usize];\n    for i in (1..v_max).rev() {\n        v.push(i);\n    }\n    v\n}\n\nfn get_sums(keys: &[u64]) -&gt; Dict {\n    // Initialisation du hashmap\n    let mut hmap = HashMap::new();\n    for key in keys.iter() {\n        let big_key = *key as u128;\n        let value = (big_key * (big_key + 1)) / 2 - 1;\n        hmap.insert(*key, value);\n    }\n    hmap\n}\n\nfn calculate_sums(mut hmap: Dict, keys: &[u64], square_n: u64) -&gt; Dict {\n    for p in 2..square_n + 1 {\n        let current_sum = hmap[&(p - 1)];\n        if hmap[&p] &gt; current_sum {\n            let p_square = p * p;\n            for key in keys.iter() {\n                if *key &lt; p_square {\n                    break;\n                }\n                let new_value = hmap[&key] - (p as u128) * (hmap[&(key / p)] - current_sum);\n                hmap.insert(*key, new_value);\n            }\n        }\n    }\n    hmap\n}\n\nfn primes(n: u64) -&gt; u128 {\n    let square_n = (n as f64).sqrt() as u64;\n    assert!(square_n * square_n &lt;= n && (square_n + 1).pow(2) &gt; n);\n    let half_size = square_n - 1;\n    let keys = get_keys(n, half_size);\n    let p_keys = &keys;\n    let mut all_sums = get_sums(p_keys);\n    all_sums = calculate_sums(all_sums, p_keys, square_n);\n    all_sums[&n]\n}\n\nfn format(dist: usize, value: &String) -&gt; String {\n    let mut v: String = value.to_string();\n    for _ in 1..(dist - (*value).len()) {\n        v += &\" \";\n    }\n    return v;\n}\n\nfn main() {\n    println!(\"Power | Time (µs) | Resultat\");\n    println!(\"========================================\");\n    for i in 1..9 {\n        let now = Instant::now();\n        let n: u64 = (10_u64).pow(i);\n        let value: u128 = primes(n);\n        let new_now = Instant::now();\n        println!(\n            \"{} | {} | {}\",\n            format(6, &(i.to_string())),\n            format(10, &(new_now.duration_since(now).as_micros().to_string())),\n            value\n        );\n    }\n}\n#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;cmath&gt;\n#include &lt;assert.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unordered_map&gt;\n#include &lt;chrono&gt;\n#include &lt;string&gt;\nusing namespace std::chrono;\nusing namespace std;\n\ntypedef unordered_map&lt;long, long long&gt; umap;\n\nvoid generate_key_array(long long key_array[], long long n, long half_size){\n  // generation of a key array which serves for the dictionary all_sums\n  long long value;\n\n  for(long index = 0; index &lt;= half_size+1; index++){\n    value = (long long) n / (index + 1);\n    key_array[index] = value;\n  }\n\n  for(long index = half_size + 1; index &lt; 2 * half_size + 1; index++){\n    value = key_array[index - 1] - 1;\n    key_array[index] = value;\n  }\n}\n\nvoid generate_all_sums(umap& all_sums, long long key_array[], long size){\n  // generation of dictionary all_sums\n  long long value;\n\n  for(long index = 0; index &lt; size; index++){\n    value = key_array[index];\n    // storing sum of numbers for 1 to key\n    all_sums[value] = ((long long) (value*(value + 1))/2) - 1;\n  }\n}\n\n\nvoid calculate_new_sums(umap& all_sums, long long key_array[], long long square_root){\n  // core of the program for calculate the sum of prime numbers\n  long long current_sum;\n  long long p_square;\n  long index;\n  long long key;\n  long long second_key;\n\n  for(long p = 2; p &lt;= square_root; p++){\n    current_sum = all_sums[p - 1];\n    if(all_sums[p] &gt; current_sum){ //if p is prime\n      p_square = p * p;\n      index = 0;\n      key = key_array[index];\n\n      // while the key is lower than p * p\n      while(key &gt;= p_square){\n        second_key = key / p;\n        // updating the sum of the key 'key'\n        all_sums[key] -= p * (all_sums[second_key] - current_sum);\n        index++;\n        key = key_array[index];\n      }\n    }\n  }\n}\n\nlong long P10(long long n){\n  long long square_root = (long long) sqrt(n);\n  //check if the program will work\n  assert ((square_root*square_root &lt;= n) && ((square_root + 1) * (square_root + 1) &gt; n));\n\n  long long final_sum;\n  long half_size = square_root - 1;\n\n  long long* key_array = new long long [half_size * 2 + 1];\n  generate_key_array(key_array, n, half_size);\n\n  long size = 2 * half_size + 1;\n  // dictionary of sums\n  umap all_sums;\n  generate_all_sums(all_sums, key_array, size);\n  calculate_new_sums(all_sums, key_array, square_root);\n\n  final_sum = all_sums[n];\n  delete key_array;\n  all_sums.clear();\n\n  return final_sum;\n}\n\nstring format(int dist, string value){\n  string hole = \"\";\n  for(int _=0; _&lt;=(dist-(int)(value).size()); _++){\n    hole+=\" \";\n  }\n  return value + hole;\n}\n\n\nint main(){\n  // Goal: 100 000 000 000\n  // Awaited result: 201 467 077 743 744 681 014\n  auto start = high_resolution_clock::now();\n  long long value;\n  cout &lt;&lt; \"Power | Time (µs) | Result\" &lt;&lt; endl;\n  cout &lt;&lt; \"========================================\" &lt;&lt; endl;\n  for(int i=1; i&lt;=8; i++){\n    // cout &lt;&lt; \"Power: \" &lt;&lt; i &lt;&lt; endl;\n    value = P10(pow(10,i));\n    auto stop = high_resolution_clock::now();\n    auto duration = duration_cast&lt;microseconds&gt;(stop - start);\n    // cout &lt;&lt; value &lt;&lt; endl;\n    // cout &lt;&lt; \"Time taken by function: \" &lt;&lt; duration.count() &lt;&lt; \" x 10e(-3) seconds\" &lt;&lt; endl;\n    cout &lt;&lt; format(4, std::to_string(i)) &lt;&lt; \" | \" &lt;&lt; format(8, to_string(duration.count())) &lt;&lt; \" | \" &lt;&lt; value &lt;&lt; endl;\n  }\n  return 0;\n}\ndefmodule Primes do\n  @spec sqrt(integer) :: integer\n  defp sqrt(n) do\n    trunc(:math.sqrt(n))\n  end\n\n  @spec head_keys(integer, integer) :: [integer]\n  defp head_keys(n, root_n) do\n    1..(root_n + 1)\n    |&gt; Enum.map(&div(n, &1))\n  end\n\n  @spec tail_keys(integer, integer) :: [integer]\n  defp tail_keys(n, root_n) do\n    Enum.to_list(div(n, root_n)..1)\n  end\n\n  @spec generate_keys(integer, integer) :: [integer]\n  defp generate_keys(n, root_n) do\n    head_keys(n, root_n) ++ tail_keys(n, root_n)\n  end\n\n  @spec n_sums(integer) :: {integer}\n  defp n_sums(i) do\n    {i, div(i * (i + 1), 2) - 1}\n  end\n\n  @spec generate_sums([integer]) :: %{integer =&gt; integer}\n  defp generate_sums(keys) do\n    Enum.into(keys, %{}, &n_sums(&1))\n  end\n\n  @spec small(integer, %{integer =&gt; integer}, integer, integer) :: {integer}\n  defp small(v, dict, p, sp) do\n    {v, dict[v] - p * (dict[div(v, p)] - sp)}\n  end\n\n  @spec calculate(%{integer =&gt; integer}, [integer], integer, integer) :: %{integer =&gt; integer}\n  defp calculate(sums, keys, p, limit) when p &lt; limit do\n    sum_p = sums[p - 1]\n\n    if sums[p] &gt; sum_p do\n      Enum.take_while(keys, &(&1 &gt;= p * p))\n      |&gt; Enum.into(%{}, &small(&1, sums, p, sum_p))\n      |&gt; (&Map.merge(sums, &1)).()\n      |&gt; calculate(keys, p + 1, limit)\n    else\n      calculate(sums, keys, p + 1, limit)\n    end\n  end\n\n  @spec calculate(%{integer =&gt; integer}, [integer], integer, integer) :: %{integer =&gt; integer}\n  defp calculate(sums, _, p, limit) when p &gt;= limit do\n    sums\n  end\n\n  @spec sum_up_to(integer) :: integer\n  def sum_up_to(n) do\n    root_n = sqrt(n)\n    keys = generate_keys(n, root_n)\n    sums = generate_sums(keys)\n    calculate(sums, keys, 2, root_n + 1)[n]\n  end\n\n  @spec measure(function) :: integer\n  def measure(function) do\n    function\n    |&gt; :timer.tc()\n    |&gt; elem(0)\n    # divide by 1_000 for milliseconds\n    |&gt; Kernel./(1)\n  end\nend\n\ndefmodule Formatter do\n  @spec add_space(integer, charlist) :: charlist\n  defp add_space(0, string) do\n    string\n  end\n\n  @spec add_space(integer, charlist) :: charlist\n  defp add_space(i, string) do\n    add_space(i - 1, string &lt;&gt; \" \")\n  end\n\n  @spec format(integer, integer) :: charlist\n  defp format(dist, value) do\n    string_v = \"#{value}\"\n    add_space(dist - String.length(string_v), string_v)\n  end\n\n  @spec format_all(integer, integer, integer) :: nil\n  def format_all(power, time, value) do\n    IO.puts(\"#{format(5, power)} | #{format(9, time)} | #{value}\")\n  end\nend\n\nIO.puts(\"Power | Time (µs) | Result\")\nIO.puts(\"=========================================\")\n\nPrimes.sum_up_to(100)\n\n1..8\n|&gt; Enum.map(fn exp -&gt;\n  f = Primes.measure(fn -&gt; Primes.sum_up_to(:math.pow(10, exp) |&gt; round) end)\n  Formatter.format_all(exp, f |&gt; round, Primes.sum_up_to(:math.pow(10, exp) |&gt; round))\nend)\nimport java.util.HashMap;\nimport java.util.Vector;\nimport java.lang.Math;\n\npublic class Main{\n\n    static Vector&lt;Integer&gt; get_keys(Integer n, Integer half_size){\n        Vector&lt;Integer&gt; V = new Vector&lt;&gt;();\n        for (Integer i = 0; i &lt; half_size; i++){\n            V.add(n / (i + 1));\n        }\n        Integer vmax = V.get(V.size() - 1) - 1;\n        for (Integer i = vmax; i &gt; 0; i--){\n            V.add(i);\n        }\n        return V;\n    }\n\n    static HashMap&lt;Integer, Long&gt; get_sums(Vector&lt;Integer&gt; keys){\n        HashMap&lt;Integer, Long&gt; hmap = new HashMap&lt;&gt;();\n        for (int key: keys){\n            long big_key = key;\n            long value = (big_key * (big_key + 1)) / 2 - 1;\n            hmap.put(key, value);\n        }\n        return hmap;\n    }\n\n    static HashMap&lt;Integer, Long&gt; calculate_sums(HashMap&lt;Integer, Long&gt; hmap, Vector&lt;Integer&gt; keys, int square_n){\n        for (Integer p = 2; p &lt; square_n + 1; p++){\n            long current_sum = hmap.get(p - 1);\n            if (hmap.get(p) &gt; current_sum){\n                long p_square = p * p;\n                for (int key: keys){\n                    if (key &lt; p_square){\n                        break;\n                    }\n                    long new_value = hmap.get(key) - (long)p * (hmap.get(key / p) - current_sum);\n                    hmap.put(key, new_value);\n                }\n            }\n        }\n        return hmap;\n    }\n\n    static long primes(int n){\n        int square_n = (int) Math.sqrt(n);\n        assert square_n * square_n &lt;= n && (square_n + 1) * (square_n + 1) &gt; n;\n        int half_size = square_n - 1;\n        Vector&lt;Integer&gt; keys = Main.get_keys(n, half_size);\n        HashMap&lt;Integer, Long&gt; all_sums = Main.get_sums(keys);\n        all_sums = Main.calculate_sums(all_sums, keys, square_n);\n        return all_sums.get(n);\n    }\n\n    static String format(int dist, String value){\n        return value + \" \".repeat(dist - value.length());\n    }\n\n    public static void main(String[] args){\n        Main App = new Main();\n        System.out.println(\"Power | Time (µs) | Resultat\");\n        System.out.println(\"========================================\");\n        primes(100);\n        for (int i = 1; i &lt; 9; i++){\n            long start = System.nanoTime();\n            long result = primes((int) Math.pow(10, i));\n            long duration = (System.nanoTime() - start) / 1_000;\n            System.out.println(\n                Main.format(5, String.valueOf(i)) + \" | \" +\n                Main.format(9, String.valueOf(duration)) + \" | \" +\n                String.valueOf(result)\n            );\n        }\n    }\n}\nfunction P10(n)\n    r = math.floor(n^0.5)\n    assert(r * r &lt;= n and (r + 1)^2 &gt; n)\n    V = {}\n    for i = 1, r + 1, 1 do\n        table.insert(V, n // i)\n    end\n    for i = V[#V] - 1, 1, -1 do\n        table.insert(V, i)\n    end\n    S = {}\n    for _, i in ipairs(V) do\n        S[i] = i * (i + 1) // 2 - 1\n    end\n    for p = 2, r, 1 do\n        if S[p] &gt; S[p - 1] then\n            sp = S[p - 1]\n            p2 = p * p\n            for _, v in ipairs(V) do\n                if v &lt; p2 then\n                    break\n                end\n                S[v] = S[v] - p * (S[v // p] - sp)\n            end\n        end\n    end\n    return S[n]\nend\n\nfunction format(dist, value)\n    return value .. string.rep(\" \", (dist - string.len(value)))\nend\n\nprint(\"Power | Time (µs) | Resultat\")\nprint(\"========================================\")\nfor i = 1, 8, 1 do\n    start = os.clock()\n    result = P10(math.floor(10^i))\n    duration = math.floor((os.clock() - start) * 10^6)\n    print(format(5, tostring(i)) .. \" | \" .. format(9, tostring(duration)) .. \" | \" .. tostring(result))\nend\nconst {performance} = require(\"perf_hooks\");\n\nfunction P10(n){\n    var r = Math.floor(n ** 0.5);\n    console.assert(r * r &lt;= n && Math.pow(r + 1, 2) &gt; n);\n    var V = [];\n    for (let i = 1; i &lt; r + 1; i++){\n        V.push(Math.floor(n / i));\n    }\n    for (let i = V[V.length - 1] - 1; i &gt; 0; i--){\n        V.push(i);\n    }\n    var S = V.reduce((S, i) =&gt; {\n        S[i] = Math.floor(i * (i + 1) / 2) - 1\n        return S;\n    }, {});\n    var length = V.length;\n    for (let p = 2; p &lt; r + 1; p++){\n        if (S[p] &gt; S[p - 1]) {\n            var sp = S[p - 1];\n            var p2 = p * p;\n            for (let index = 0; index &lt; length; index++){\n                let v = V[index];\n                if (v &lt; p2){\n                    break;\n                }\n                S[v] -= p * (S[Math.floor(v / p)] - sp);\n            }\n        }\n    }\n    return S[n];\n}\n\nfunction format(dist, value){\n    return value + \" \".repeat(dist - value.length)\n}\n\nconsole.log(\"Power | Time (µs) | Resultat\")\nconsole.log(\"========================================\")\nP10(100)\nfor (let i=1; i&lt;9; i++){\n    var start = performance.now();\n    var result = P10(Math.floor(Math.pow(10, i)));\n    var duration = Math.floor((performance.now() - start) * 1_000);\n    console.log(format(5, String(i)) + \" | \" + format(9, String(duration)) + \" | \" + String(result));\n}\nimport scala.collection.mutable.HashMap\nimport scala.collection.immutable.Vector\nimport scala.math.sqrt\nimport scala.math.pow\nimport scala.math.BigInt\n\ndef get_keys(n: Long, half_size:Long): Vector[Long] =\n  var v = Vector.range(0L, half_size + 1L).map(i =&gt; n / (i + 1))\n  val vmax = v(half_size.asInstanceOf[Int])\n  v ++ Vector.range(1L, vmax).reverse\n\ndef get_sums(keys: Vector[Long]) : HashMap[Long, BigInt] =\n  var hmap = HashMap.empty[Long, BigInt]\n  for key &lt;- keys do\n    val k = BigInt(key)\n    val value = (k * (k + 1)) / 2 - 1\n    hmap.put(key, value)\n  hmap \n\ndef calculate_sums(hmap: HashMap[Long, BigInt], keys: Vector[Long], square_n: Long): HashMap[Long, BigInt] =\n  var cmap = hmap.clone()\n  for p &lt;- (2L to square_n) do\n    val current_sum = cmap(p - 1)\n    if (cmap(p) &gt; current_sum) {\n      val p_square = p * p\n      for key &lt;- keys.takeWhile(p =&gt; p &gt;= p_square) do\n        val new_value = cmap(key) - p * (cmap(key / p) - current_sum)\n        cmap.update(key, new_value)\n    }\n  cmap\n\ndef primes(n: Long): BigInt =\n  val square_n = sqrt(n.asInstanceOf[Float]).asInstanceOf[Long]\n  val half_size = square_n - 1\n  val keys = get_keys(n, half_size)\n  var all_sums = get_sums(keys)\n  all_sums = calculate_sums(all_sums, keys, square_n)\n  all_sums(n)\n\ndef add_space(i:Int, string:String) : String =\n  if (i == 0){\n    return string\n  } else {\n    return add_space(i - 1, string.concat(\" \"))\n  }\n\ndef format(dist:Int, string: String): String =\n  add_space(dist - string.length(), string)\n\n@main def main() =\n  val result = primes(10)\n  println(\"Power | Time (µs) | Resultat\")\n  println(\"========================================\")\n  for power &lt;- (1 to 8) do\n    val start = System.nanoTime\n    val n = pow(10.0, power.asInstanceOf[Double]).asInstanceOf[Long]\n    val result = primes(n)\n    val duration = ((System.nanoTime - start) / 1e3d).asInstanceOf[Int]\n    println(s\"${format(5, s\"$power\")} | ${format(9, s\"$duration\")} | $result\")\n\n\nGraph\nThe first graph is the execution time (in \\(\\mu s\\)) given the power of \\(10^x\\). The second graph is the execution time (in \\(\\log(\\mu s)\\)) after the application of the logarithm function given the power of \\(10^x\\). You can interact with the legend (for instance, click on elixir).\n\n\n\n\n\n\n\n\nNotes\nThe idea comes from the challenge Euler problem n°245 where one part of the problem involves to compute the sum of prime numbers up to \\(10^{11}\\).\nGitHub Repository"
  },
  {
    "objectID": "posts/involute-bevel-gear-part-3/index.html",
    "href": "posts/involute-bevel-gear-part-3/index.html",
    "title": "Bevel Tooth Profile (Part 3)",
    "section": "",
    "text": "Figure : Transmission with torque\n\n\nIn this part, we are going to code a complete bevel gear profile in Python.\nLibraries requires are PyGLM and manim\n\nSpherical involute function\nThe following code is the translation of the relation:\n\\[\n\\overrightarrow{\\theta(t, t_0, \\gamma)} = \\begin{pmatrix}\n    \\sin(\\gamma) \\cos(\\sin(\\gamma) \\cdot t) \\cos(t + t_0) + \\sin(\\sin(\\gamma) \\cdot t) \\sin(t + t_0) \\\\\n    \\sin(\\gamma) \\cos(\\sin(\\gamma) \\cdot t) \\sin(t + t_0) - \\sin(\\sin(\\gamma) \\cdot t) \\cos(t + t_0) \\\\\n    \\cos(\\gamma) \\cos(\\sin(\\gamma) \\cdot t)\n\\end{pmatrix}\n\\]\nfrom glm import *\nfrom math import *\n\ndef spherical_involute(cone_angle:float, t0:float, t:float) -&gt; vec3:\n    \"\"\"\n    Return spherical involute function\n\n    Parameters\n    ----------\n    t : float\n        The angular position\n    t0 : float\n        The difference phase\n    cone_angle : float\n        The cone angle\n\n    Returns\n    -------\n    vec3\n        A point on the spherical involute\n    \"\"\"\n    cos_g, sin_g = cos(cone_angle), sin(cone_angle)\n    return vec3(\n        sin_g * cos(t * sin_g) * cos(t + t0) + sin(t * sin_g) * sin(t + t0),\n        sin_g * cos(t * sin_g) * sin(t + t0) - sin(t * sin_g) * cos(t + t0),\n        cos_g * cos(t * sin_g),\n    )\n\n\nInterference function\nThe following code is the translation of the relation:\n\\[\n\\overrightarrow{\\theta_{int}(t, t_0, \\alpha)} = \\cos(\\alpha) \\cdot \\overrightarrow{\\theta(t, t_0, \\gamma_p)} + \\sin(\\alpha) \\cdot \\overrightarrow{\\gamma_{int}(t + t_0)}\n\\]\nwhere\n\\[\n\\overrightarrow{\\gamma_{int}(t)} = \\begin{pmatrix}\n    -\\cos(\\gamma_p) \\cos(t) \\\\\n    -\\cos(\\gamma_p) \\sin(t) \\\\\n    \\sin(\\gamma_p)\n\\end{pmatrix}\n\\]\nfrom glm import *\nfrom math import *\n\ndef spherical_involuteof(\n    pitch_cone_angle:float, t0:float, alpha:float, t:float\n) -&gt; vec3:\n    \"\"\"\n    Return the spherical interference function\n\n    Parameters\n    ----------\n    t : float\n        The angular position\n    t0 : float\n        The difference phase\n    pitch_cone_angle : float\n        The pitch cone angle\n    alpha : float\n        The height angle offset of the rack\n\n    Returns\n    -------\n    vec3\n        A point on the spherical interference function\n    \"\"\"\n    cos_p, sin_p = cos(pitch_cone_angle), sin(pitch_cone_angle)\n    return (\n        cos(alpha) * spherical_involute(pitch_cone_angle, t0, t) \n        + sin(alpha) * vec3(-cos_p * cos(t + t0), -cos_p * sin(t + t0), sin_p)\n    )\n\n\n\n\n\n\nNote\n\n\n\nThe angle \\(\\beta\\) is included in the difference phase \\(t_0\\).\n\n\n\n\nIntersection between the spherical interference function and the spherical involute function\nTo get the intersection between both functions, we are going to use the Newton’s Method to solve this problem.\nThe function that we want to minimize is defined as:\n\\[\nf(t_1, t_2, t_{01}, t_{02}) = \\overrightarrow{\\theta(t_1, t_{01}, \\gamma)} - \\overrightarrow{\\theta_{int}(t_2, t_{02}, \\alpha)}\n\\]\nFirst, we need to differenciate both functions. The derivative of the spherical involute function is:\n\\[\n\\overrightarrow{\\theta'(t, t_0, \\gamma)} = \\begin{pmatrix}\n    \\cos(\\gamma)^2 \\sin(\\gamma \\cdot t) \\cos(t + t_0) \\\\\n    \\cos(\\gamma)^2 \\sin(\\gamma \\cdot t) \\sin(t + t_0) \\\\\n    -\\cos(\\gamma) \\sin(\\gamma) \\sin(\\gamma \\cdot t)\n\\end{pmatrix}\n\\]\nAnd the derivative of the spherical interference function is:\n\\[\n\\overrightarrow{\\theta_{int}'(t, t_0, \\alpha)} = \\cos(\\alpha) \\cdot \\overrightarrow{\\theta'(t, t_0, \\gamma_p)} + \\sin(\\alpha) \\begin{pmatrix}\n    \\cos(\\gamma_p) \\sin(t + t_0) \\\\\n    -\\cos(\\gamma_p) \\cos(t + t_0) \\\\\n    0\n\\end{pmatrix}\n\\]\nThen we construct the jacobian matrix: \\[\nJ(t_1, t_2, t_{01}, t_{02}) = \\begin{pmatrix}\n    \\overrightarrow{\\theta'(t_1, t_{01}, \\gamma)} &\n    -\\overrightarrow{\\theta_{int}'(t_2, t_{02}, \\alpha)} &\n    \\vec z\n\\end{pmatrix}\n\\]\n\n\n\n\n\n\nNote\n\n\n\nThe angles \\(t_{01}\\) and \\(t_{02}\\) are constants well-known. Only the angles \\(t_1\\) and \\(t_2\\) are the variables.\n\n\nThe following code is the translation of these relations:\nfrom glm import *\nfrom math import *\n\ndef derived_spherical_involute(cone_angle:float, t0:float) -&gt; callable:\n    \"\"\"\n    Return the function of the derived spherical involute function.\n\n    Parameters\n    ----------\n    cone_angle : float\n        The cone angle\n    t0 : float\n        The phase difference\n\n    Returns\n    -------\n    callable\n        Derived spherical involute function\n    \"\"\"\n    cos_g, sin_g = cos(cone_angle), sin(cone_angle)\n    return lambda t: vec3(\n        cos_g ** 2 * sin(t * sin_g) * cos(t + t0),\n        cos_g ** 2 * sin(t * sin_g) * sin(t + t0),\n        -cos_g * sin_g * sin(t * sin_g),\n    )\n\n\ndef jacobian_spherical_involute(\n    base_cona_angle:float, pitch_cone_angle:float, t01:float, t02:float, alpha:float\n) -&gt; callable:\n    \"\"\"\n    Return the function of the jacobian used for the newton method in\n    `spherical_gearprofile`\n\n    Parameters\n    ----------\n    base_cona_angle : float\n        The base cone angle\n    pitch_cone_angle : float\n        The pitch cone angle\n    t01 : float\n        The phase of the spherical involute function\n    t02 : float\n        The phase of the spherical interference function\n    alpha : float\n        The height angle offset of the rack\n\n    Returns\n    -------\n    callable\n        Jacobian to get the intersection between the spherical involute\n        function the spherical interference function\n    \"\"\"\n    dsi = derived_spherical_involute # for convenience\n    derived_involute = dsi(base_cona_angle, t01)\n    cos_p = cos(pitch_cone_angle)\n    vec = lambda t: vec3(cos_p * sin(t), -cos_p * cos(t), 0)\n    derived_interference = lambda t: (\n        dsi(pitch_cone_angle, t02)(t) * cos(alpha) + sin(alpha) * vec(t + t02)\n    )\n    return lambda t1, t2: mat3(\n        derived_involute(t1),\n        -derived_interference(t2),\n        vec3(0, 0, 1),\n    )\n\n\nRack parameters\nRack parameters are useful better placements or to get dimensions:\nfrom glm import *\nfrom math import *\n\ndef spherical_rack_tools(\n    z:float, pressure_angle:float = pi / 9, ka:float = 1, kd:float = 1.25\n):\n    \"\"\"\n    Return a list of all information useful to generate a spherical rack.\n\n    Parameters\n    ----------\n    z : float\n        Number of tooth of the rack equal to `z_pinion / sin(pitch_cone_angle)`\n        or `z_wheel / sin(shaft_angle - pitch_cone_angle)`\n    pressure_angle : float\n        The pressure angle of the gear\n    ka : float\n        The addendum coefficient\n    kd : float\n        The dedendum coefficient\n\n    Returns\n    -------\n    tuple\n        * the minimum abscissa for the function (fifth element)\n        * the maximum abscissa for the function (fifth element)\n        * the phase of a tooth\n        * the phase of space\n        * the function to generate a tooth\n    \"\"\"\n    k = 1 / z\n    gamma_p = 0.5 * pi\n    gamma_b = asin(cos(pressure_angle))\n    cos_b, sin_b = cos(gamma_b), sin(gamma_b)\n    gamma_f = gamma_p + atan2(2 * ka * k, 1)\n    gamma_r = gamma_p - atan2(2 * kd * k, 1)\n\n    phi_p = acos(tan(gamma_b) / tan(gamma_p))\n    theta_p = atan2(sin_b * tan(phi_p), 1) / sin_b - phi_p\n    phase_diff = k * pi + 2 * theta_p\n\n    t_min = acos(cos(gamma_r) / cos_b) / sin_b\n    t_max = acos(cos(gamma_f) / cos_b) / sin_b\n\n    involute = lambda t, t0: spherical_involute(gamma_b, t0, t)\n    v = vec3(1, 1, 0)\n    phase_empty = 2 * pi * k - anglebt(\n        involute(t_min, 0) * v, involute(-t_min, phase_diff) * v\n    )\n\n    return [t_min, t_max, phase_diff, phase_empty, involute]\n\n\nSpherical gear profile\nNow we have all of these functions, we can make a spherical gear profile:\nfrom gml import *\nfrom manim import *\nfrom math import *\n\ndef spherical_gearprofile(\n    z:int, \n    step: float,\n    pitch_cone_angle:float, \n    pressure_angle:float = pi / 9, \n    ka:float = 1, \n    kd:float = 1.25, \n):\n    \"\"\"\n    Generate 1-period tooth spherical profile for a bevel gear\n\n    Parameters\n    ----------\n    z : int\n        Number of tooth on the gear this profile is meant for\n    step : float\n        Step of a tooth\n    pitch_cone_angle : float\n        The pitch cone angle\n    pressure_angle : float\n        Pressure angle of the tooth\n    ka : float\n        Addendum coefficient\n    kd : float\n        Dedendum coefficient\n    \"\"\"\n    # Initialization of parameters\n    gamma_p = pitch_cone_angle # for convenience\n    rp = z * step / (2 * pi)\n    rho1 = rp / sin(gamma_p)\n    gamma_b = asin(cos(pressure_angle) * sin(gamma_p))\n    cos_b, sin_b = cos(gamma_b), sin(gamma_b)\n    tooth_size = pi / z\n    involute = lambda t, t0 : spherical_involute(gamma_b, t0, t)\n    epsilon_p = acos(cos(gamma_p) / cos_b) / sin_b\n    theta_p = anglebt(\n        involute(0, 0) * vec3(1, 1, 0), involute(epsilon_p, 0) * vec3(1, 1, 0)\n    )\n    phase_diff = tooth_size + 2 * theta_p\n    phase_empty = phase_interference = 2 * pi / z - phase_diff\n    # The following number `k` is useful to simplify some calculations\n    # It's broadly speaking `1/z_rack` and `z_rack` is not an integer !\n    k = sin(gamma_p) / z\n\n    # Spherical involute part\n    gamma_f = gamma_p + atan2(2 * ka * k, 1) # addendum cone angle\n    gamma_r = gamma_p - atan2(2 * kd * k, 1) # dedendum cone angle\n    t_min = 0\n    t_max = acos(cos(gamma_f) / cos_b) / sin_b\n    if gamma_r &gt; gamma_b:\n        v = vec3(1, 1, 0)\n        t_min = acos(cos(gamma_r) / cos_b) / sin_b\n        phase_empty = 2 * pi / z - anglebt(\n            involute(t_min, 0) * v, involute(-t_min, phase_diff) * v\n        )\n\n    # Calculation of offsets due to geometry of spherical rack\n    _, t_rack_max, phase1, _, rinvolute = spherical_rack_tools(\n        1 / k, pressure_angle, ka, kd\n    )\n    interference = lambda t, t0 : spherical_involuteof(gamma_p, t0, alpha, t)\n    alpha = atan2(2 * ka * k, 1)\n    n1 = rinvolute(t_rack_max, 0) * vec3(1, 1, 0)\n    n2 = rinvolute(-t_rack_max, phase1) * vec3(1, 1, 0)\n    beta = 0.5 * anglebt(n1, n2) * length(n1) / sin_b\n\n    # Newton method to calculate the intersection between\n    # the spherical involute and the spherical interference.\n    # Objective function\n    involuteat = lambda t2, t0 : spherical_involuteof(gamma_p, t0, alpha, t2)\n    f = lambda t1, t2: (\n        involute(t1, 0) - involuteat(t2, -0.5 * phase_interference + beta)\n    )\n    # Jacobian matrix\n    J = jacobian_spherical_involute(\n        gamma_b, gamma_p, 0, -0.5 * phase_interference + beta, alpha\n    )\n\n    # Compute the intersection values\n    t1, t2, t3 = 0.5 * t_max, -0.5 * t_max, 0\n    for i in range(8):\n        t1, t2, t3 = vec3(t1, t2, t3) - inverse(J(t1, t2)) * f(t1, t2)\n\n    # Build sides of a tooth\n    interference1 = ParametricFunction(\n        lambda t: rho1 * interference(t, -0.5 * phase_interference + beta),\n        t_range=[t2, 0],\n    )\n    interference2 = ParametricFunction(\n        lambda t: rho1 * interference(\n            -t, phase_diff + 0.5 * phase_interference - beta\n        ),\n        t_range=[t2, 0],\n    )\n    side1 = ParametricFunction(\n        lambda t: rho1 * involute(t, 0), t_range=[t1, t_max]\n    )\n    side2 = ParametricFunction(\n        lambda t: rho1 * involute(-t, phase_diff), t_range=[t1, t_max]\n    )\n\n    # Extreme points of sides to compute angle between them\n    a = rho1 * interference(0, -0.5 * phase_interference + beta)\n    b = rho1 * interference(0, phase_diff + 0.5 * phase_interference - beta)\n    final_phase_empty = 2 * pi / z - anglebt(a * vec3(1, 1, 0), b * vec3(1, 1, 0))\n    top = Line(rho1 * involute(t_max, 0), rho1 * involute(-t_max, phase_diff))\n    bottom = Line(rotate(-final_phase_empty, vec3(0, 0, 1)) * a, a)\n\n    aligned_phase = anglebt(\n        (\n            rho1 * involute(t_max, 0) + rho1 * involute(-t_max, phase_diff)\n        ) * 0.5 * vec3(1, 1, 0),\n        X,\n    )\n\n    return VGroup(\n        interference1,\n        interference2,\n        side1,\n        side2,\n        top,\n        bottom,\n        Dot(a, radius=0.03),\n        Dot(b, radius=0.03),\n        Dot(rho1 * involute(t1, 0), radius=0.03),\n        Dot(rho1 * involute(t_max, 0), radius=0.03),\n        Dot(rho1 * involute(-t1, phase_diff), radius=0.03),\n        Dot(rho1 * involute(-t_max, phase_diff), radius=0.03),\n    ).rotate_about_origin(-aligned_phase, Z)\n\n\nOne last function\nThe last function is get_pitch_cone_angle to determine the pitch cone angle given the number of teeth of the wheel and those of the pinion:\nfrom math import *\n\ndef get_pitch_cone_angle(\n    z_pinion: int, z_wheel: int, shaft_angle: float = 0.5 * pi\n) -&gt; float:\n    \"\"\"\n    Return the pitch cone angle of the pinion called `gamma_p`.\n    The pitch cone angle of the wheel is equal to `shaft_angle - gamma_p`.\n\n    Parameters\n    ----------\n    z_pinion : int\n        The number of teeth on the bevel pinion\n    z_wheel : int\n        The number of teeth on the bevel wheel\n    shaft_angle : float\n        The shaft angle\n\n    Returns\n    -------\n    float\n        The pitch cone angle\n    \"\"\"\n    return atan2(sin(shaft_angle), ((z_wheel / z_pinion) + cos(shaft_angle)))\n\n\nExample to make a spherical gear profile\nz_pinion = 10\nz_wheel = 20\nm = 0.5\nstep = pi * m\npressure_angle = pi / 9\npitch_cone_angle = get_pitch_cone_angle(z_pinion, z_wheel)\n\ngamma_p = pitch_cone_angle # for convenience\nrp = z_pinion * step / (2 * pi)\nrho1 = rp / sin(gamma_p)\n\nangle1tooth_pinion = 2 * pi / z_pinion\n\ndef revolution(vgroup, angle, times):\n    final_vgroup = vgroup.copy()\n    for i in range(times):\n        rotated_vgroup = vgroup.copy().rotate_about_origin(angle * i)\n        for line in rotated_vgroup:\n            final_vgroup += line\n    return final_vgroup\n\npinion_profile = revolution(\n    spherical_gearprofile(z_pinion, step, pitch_cone_angle),\n    angle1tooth_pinion,\n    z_pinion,\n)\n\nangle1tooth_wheel = 2 * pi / z_wheel\nwheel_profile = revolution(\n    spherical_gearprofile(z_wheel, step, pi / 2 - pitch_cone_angle),\n    angle1tooth_wheel,\n    z_wheel,\n)\n\n\nBonus : spherical rack profile\nRemember that the spherical rack does not have an integer number of teeth. The number of teeth of the rack is:\n\\[\nz_{\\text{rack}} = \\frac{z_{\\text{pinion}}}{\\sin([\\text{pitch cone angle}]_{\\text{pinion}})}\n\\]\nHere is the code to make a spherical rack profile:\nz = z_pinion = 10\nz_wheel = 20\nm = 0.5\nstep = pi * m\npressure_angle = pi / 9\nka = 1\nkd = 1.25\npitch_cone_angle = get_pitch_cone_angle(z_pinion, z_wheel)\n\ngamma_p = pitch_cone_angle # for convenience\ngamma_b = asin(cos(pressure_angle) * sin(gamma_p))\nrp = z_pinion * step / (2 * pi)\nrho1 = rp / sin(gamma_p)\n\nt_min, t_max, phase1, phase2, involute = spherical_rack_tools(z, pressure_angle, ka, kd)\n\ndef revolution(vgroup, angle, times):\n    final_vgroup = vgroup.copy()\n    for i in range(times):\n        rotated_vgroup = vgroup.copy().rotate_about_origin(angle * i)\n        for line in rotated_vgroup:\n            final_vgroup += line\n    return final_vgroup\n\nside1 = ParametricFunction(\n    lambda t: rho1 * involute(t, 0), t_range=[t_min, t_max]\n)\nside2 = ParametricFunction(\n    lambda t: rho1 * involute(-t, phase1), t_range=[t_min, t_max]\n)\nrack = VGroup(\n    side1,\n    side2,\n    Line(rho1 * involute(t_min, -phase2), rho1 * involute(t_min, 0)),\n    Line(rho1 * involute(t_max, 0), rho1 * involute(-t_max, phase1)),\n) # one tooth\n\n# The rack is upside down\n# You can add .rotate(pi, X, about_point=O) to `rack` if you want to rotate it\n# properly\n\nrack = revolution(\n    rack,\n    anglebt(\n        involute(t_min, -phase2) * (X + Y),\n        involute(-t_min, phase1) * (X + Y),\n    ),\n    5 # arbitrary number of teeth\n)"
  },
  {
    "objectID": "posts/involute-spur-gear/index.html",
    "href": "posts/involute-spur-gear/index.html",
    "title": "Spur Tooth Profile",
    "section": "",
    "text": "Involute gears are the most popular power transmission devices. We find them as an essential component for many machines. For instance, epicyclic gear train is a combination of gears which allows to make a reduction in a compact way. Spur gears are the most popular form and the most efficient type of gearing."
  },
  {
    "objectID": "posts/involute-spur-gear/index.html#code",
    "href": "posts/involute-spur-gear/index.html#code",
    "title": "Spur Tooth Profile",
    "section": "Code",
    "text": "Code\nfrom collections import namedtuple\nfrom functools import partial\nfrom manim import * # pip install manim\n\ndef profile(m, z, alpha=radians(20), ka=1, kf=1.25, interference=True):\n    # Parameters\n    ha = m * ka  #                  addendum height\n    hf = m * kf  #                  dedendum height\n    p = pi * m  #                   step\n    rp = pitch_radius(m, z) #       pitch radius\n    ra = rp + ha #                  addendum radius\n    rf = rp - hf #                  dedendum radius\n    rb = base_radius(m, z, alpha) # base radius\n\n    ta = angle_involute(ra, rb) #   addendum angle\n    tp = angle_involute(rp, rb) #   pitch angle\n\n    duplicate = (\n        lambda obj, angle: obj.copy()\n        .apply_matrix(mat3(X, -Y, Z))\n        .rotate_about_origin(angle)\n    )\n    phase = pi / z + 2 * (tp - atan2(tp, 1))\n\n    # Involute\n    side = ParametricFunction(partial(involute, r=rb), t_range=[0, ta])\n\n    # Arc parameters\n    ArcParameters = namedtuple(\"ArcParameters\", [\"center\", \"radius\", \"angle\"])\n    r = 0.5 * (rb - rf)\n    t = -atan2(r, rf + r)\n    arcp = ArcParameters((rf + r) * u(t), r, t)\n    arc = Arc(arcp.radius, -pi + arcp.angle, -pi / 2, arc_center=arcp.center)\n\n    # Joint, top and bottom\n    angle_top = ta - atan2(ta, 1)\n    top = Arc(ra, angle_top, phase - 2 * angle_top)\n    joint = Line(arcp.center + arcp.radius * u(-3 * pi / 2 + arcp.angle), rb * X)\n    M = arcp.center + arcp.radius * u(-pi + arcp.angle)\n    angle_bottom = anglebt(M, u(0.5 * phase)) * 2\n    bottom = Line(M, rotation(-2 * pi / z + angle_bottom) * M)\n\n    # Patches\n    top_dot = Dot(ra * u(angle_top), radius=0.02)\n    side_dot = Dot(rb * X, radius=0.02)\n    point = arcp.center + arcp.radius * u(-3 * pi / 2 + arcp.angle)\n    joint_dot = Dot(point, radius=0.02)\n    bottom_dot = Dot(M, radius=0.02)\n    dots = (top_dot, side_dot, joint_dot, bottom_dot)\n\n    # Duplicated objects\n    duplicated_objs = map(\n        partial(duplicate, angle=phase), (side, arc, joint) + dots\n    )\n\n    return VGroup(\n        side, top, arc, joint, bottom, *duplicated_objs, *dots\n    ).rotate_about_origin(-phase * 0.5)\nNote : for manim, see installation"
  },
  {
    "objectID": "posts/involute-spur-gear/index.html#code-1",
    "href": "posts/involute-spur-gear/index.html#code-1",
    "title": "Spur Tooth Profile",
    "section": "Code",
    "text": "Code\nfrom collections import namedtuple\nfrom functools import partial\nfrom manim import *\n\ndef involute(t, r, t0=0):\n    return r * (u(t - t0) - t * v(t - t0))\n\n\ndef interference_curve(t, r, x, y, t0):\n    return involute(t, r, t0) - x * u(t - t0) + y * v(t - t0)\n\n\ndef derived_involute(t, r, t0):\n    return r * t * u(t - t0)\n\n\ndef derived_interference_curve(t, r, x, y, t0):\n    return derived_involute(t, r, t0) - x * v(t - t0) - y * u(t - t0)\n\n\ndef jacobian_involute(rb, rp, x, y, t0):\n    return lambda t1, t2: mat3(\n        derived_involute(t1, rb, t0), \n        -derived_interference_curve(t2, rp, x, y, t0),\n        Z,\n    )\n\ndef angle_involute(r, rb):\n    return sqrt(r * r / (rb * rb) - 1)\n\ndef profile(m, z, alpha=radians(20), ka=1, kf=1.25, interference=True):\n    # Parameters\n    ha = m * ka  #                  addendum height\n    hf = m * kf  #                  dedendum height\n    p = pi * m  #                   step\n    rp = pitch_radius(m, z) #       pitch radius\n    ra = rp + ha #                  addendum radius\n    rf = rp - hf #                  dedendum radius\n    rb = base_radius(m, z, alpha) # base radius\n\n    ta = angle_involute(ra, rb) #   addendum angle\n    tp = angle_involute(rp, rb) #   pitch angle\n\n    duplicate = (\n        lambda obj, angle: obj.copy()\n        .apply_matrix(mat3(X, -Y, Z))\n        .rotate_about_origin(angle)\n    )\n\n    la = rack.addendum_length(m, alpha, ka)\n    ts = tp - atan2(tp, 1)\n    phase = pi / z + 2 * (tp - atan2(tp, 1))\n    phase_empty = 2 * pi / z - phase\n    angle_top = ta - atan2(ta, 1)\n    tmin = la * 0.5 / rp\n\n    Functions = namedtuple(\"Functions\", [\"involute\", \"interference\"])\n    functions = Functions(\n        partial(involute, r=rb),\n        partial(interference_curve, r=rp, x=ha, y=0.5 * la, t0=phase_empty * 0.5),\n    )\n\n    # Newton method\n    f = lambda t1, t2: functions.involute(t1) - functions.interference(t2)\n    J = jacobian_involute(rb, rp, ha, 0.5 * la, phase_empty * 0.5)\n    # t3 is not used, but exists because 3D vectors\n    t1, t2, t3 = 0.5 * ta, -0.5 * ta, 0\n    for i in range(8):\n        t1, t2, t3 = vec3(t1, t2, t3) - inverse(J(t1, t2)) * f(t1, t2)\n\n    # Involute and interference curve\n    side = ParametricFunction(functions.involute, t_range=[t1, ta])\n    interference = ParametricFunction(functions.interference, t_range=[t2, tmin])\n\n    # Top and bottom\n    top = Arc(ra, angle_top, phase - 2 * angle_top)\n    M = functions.interference(tmin)\n    angle_bottom = anglebt(M, u(0.5 * phase)) * 2\n    bottom = Line(M, rotation(-2 * pi / z + angle_bottom) * M)\n\n    # Patches\n    top_dot = Dot(ra * u(angle_top), radius=0.02)\n    interference_dot = Dot(functions.interference(t2), radius=0.02)\n    involute_dot = Dot(functions.involute(t1), radius=0.02)\n    bottom_dot = Dot(M, radius=0.02)\n    dots = (top_dot, interference_dot, involute_dot, bottom_dot)\n\n    # Duplicated objects\n    duplicated_objs = map(\n        partial(duplicate, angle=phase), (side, interference) + dots\n    )\n\n    return VGroup(\n        side, interference, *duplicated_objs, top, bottom, *dots\n    ).rotate_about_origin(-phase * 0.5)\nAnd the gear profile :\n\n\n\nFigure : Gear profile with interference\n\n\nNote the closest radius to the pinion’s center is greater than the dedendum radius due to the interference curve.\nLet’s see the rack movement now :\n\n\nVideo\nAnimation : Rack moving around the pinion"
  },
  {
    "objectID": "posts/introduction-reinforcement-learning/index.html",
    "href": "posts/introduction-reinforcement-learning/index.html",
    "title": "Introduction to Reinforcement Learning",
    "section": "",
    "text": "Reinforcement Learning (RL) is a branch of Artificial Intelligence where an agent (the model) and the environment are the basic components of it. The agent interacts with the environment by taking actions and receives rewards according to the impact of the action taken. The objective of the agent is to learn to behave in such a way as to maximize the expected rewards in the long term."
  },
  {
    "objectID": "posts/introduction-reinforcement-learning/index.html#example",
    "href": "posts/introduction-reinforcement-learning/index.html#example",
    "title": "Introduction to Reinforcement Learning",
    "section": "Example",
    "text": "Example\nImagine a red dot which can move into six directions : \\(X, Y, Z, -X, -Y, -Z\\). The agent is defined as the red dot which is more precisely a model such as a deep neural network. The directions are called actions and the agent can move each step by choosing one of its actions. The environment is defined as a 3D space where the agent has a position \\((x, y, z)\\). The state of the environment is the position of the agent. \n\nGoal\nThe goal of the agent (red dot) is to find the shortest path to eat the blue dot. In this example, there is no rule to restart the experience except by waiting until the agent has successfully reached the blue dot. Therefore, a maximum of attempts of actions is defined and is higher than the minimum number of actions needed to reach the objective. An episode is an experience where the agent interacts with its environment until either having reached the objective or either having used all attempts. A similar definition of an episode is the consecutive states of the environment.\n\n\nVideo\nAnimation : The agent finds a path to eat the blue dot"
  },
  {
    "objectID": "posts/introduction-reinforcement-learning/index.html#simplifying-of-the-episode",
    "href": "posts/introduction-reinforcement-learning/index.html#simplifying-of-the-episode",
    "title": "Introduction to Reinforcement Learning",
    "section": "Simplifying of the episode",
    "text": "Simplifying of the episode\nIn order to understand how the agent will learn by exploring its environment, the example is simplified to only one step to reach the objective. The agent has only one action per episode allowed. As a result, it will either succeed or either fails.\n\n\n\nFigure : The agent has only one action per episode\n\n\n\nActions\nTo summarize about actions, there are six discrete actions that can counted :\n\n\n\nActions\n\n\n\n\n\\(A_1 = X\\)\n\n\n\\(A_2 = -X\\)\n\n\n\\(A_3 = Y\\)\n\n\n\\(A_4 = -Y\\)\n\n\n\\(A_5 = Z\\)\n\n\n\\(A_6 = -Z\\)\n\n\n\nNote in some environment, the action may be continuous which means the action is included in a range. For instance, if the action is to determine the angular position given different information from sensors, then the expected action is a number (a decimal). Whereas in this example, the output of the model is an array of probabilities of actions.\n\n\nRewards\nThe definition of the rewards is one of the keys of Reinforcement Learning. They denote the amount of success of the agent by taking a specific action. In this way, the agent receives positive and negatives rewards depending on its behavior.\n\n\n\nFigure : Table of actions and rewards\n\n\nIn this example, each action can be seen as the faces of dice if we assume that the agent is not trained and there is as much as chance between all actions. The rewards are defined by the designer in such a way that the agent is led to the objective.\n\n\nVideo\nAnimation : The agent tries different actions and gets rewards\n\n\nNote the reward is discrete (i.e. six scalar values based on actions) whereas it can be defined as the reward function. It is a function often based on the action and the environment."
  },
  {
    "objectID": "posts/introduction-reinforcement-learning/index.html#expected-reward",
    "href": "posts/introduction-reinforcement-learning/index.html#expected-reward",
    "title": "Introduction to Reinforcement Learning",
    "section": "Expected reward",
    "text": "Expected reward\nIn Reinforcement Learning, the model (the agent) has to maximize the expected reward in long term. It is the starting point for learning. The expected reward is defined as: \\[\n\\mathbb E(R(\\tau))\n\\] where \\(\\mathbb E(\\cdot)\\) is the expected value, \\(R(\\cdot)\\) is the reward function and \\(\\tau\\) is the trajectory, a set of consecutive states, actions and rewards.\nA trajectory can be seen as the path taken by the agent (set of consecutive positions and directions) and the rewards obtained through this specific path.\nThe model of the agent \\(\\pi\\) is called the policy. It denotes the current behavior of agent.\nIt is possible to compute the expected value of the policy of the agent based on the probabilities and rewards. \\[\n\\begin{align}\n\\mathbb E(R | \\pi) &= 10 \\times \\frac 1 6 - 1 \\times \\frac 1 6 - 1 \\times \\frac 1 6 - 1 \\times \\frac 1 6 - 1 \\times \\frac 1 6 - 1 \\times \\frac 1 6 \\\\\n                   &= \\frac 5 6 \\approx 0.833\n\\end{align}\n\\]\nBut it can also be seen graphically. The expected reward is the area under the curve of the reward function.\n\n\n\nFigure : Initial Expected Reward\n\n\nWhen the agent chooses different actions, it will modify the probabilities of actions based on its experience. And since its goal is to maximize the expected reward in long term, the area under the curve has to be maximized by changing probabilities.\n\n\nVideo\nAnimation : Evolution of the Expected Reward through training"
  },
  {
    "objectID": "posts/introduction-reinforcement-learning/index.html#final-result",
    "href": "posts/introduction-reinforcement-learning/index.html#final-result",
    "title": "Introduction to Reinforcement Learning",
    "section": "Final result",
    "text": "Final result\nThe agent is able to maximize an expected reward based on its experience. However, the agent will find its own path to reach its objective. It means, in most of the cases, there is an infinite number of paths and the way of going through of specific path, depends on several elements:\n\nthe environment which may cause issue depending on its definition\nthe reward function which impacts considerably the behavior of the agent\nthe policy which needs to be carefully designed\n\n\n\nVideo\nAnimation : The agent has found a path to maximize his reward, but there is an infinite number of paths\n\n\nAn ultimate important aspect of Reinforcement Learning is, although RL is a powerful way to solve problems such as games, long-term planning or robotic problems, in real world applications, the environment is dynamic, which means it changes over time. Therefore, the agent must be trained over time with new data coming from the environment. For instance, for a planning, if the agent needs to deal with a new process, it might fail if the new process is too much different from the known processes."
  },
  {
    "objectID": "posts/involute-bevel-gear-part-2/index.html",
    "href": "posts/involute-bevel-gear-part-2/index.html",
    "title": "Bevel Tooth Profile (Part 2)",
    "section": "",
    "text": "Figure : Transmission with torque\nIn this part, we will see how to fully calculate the dimensions of a bevel gear tooth, such as the interference function and more useful parameters."
  },
  {
    "objectID": "posts/involute-bevel-gear-part-2/index.html#determination-of-alpha-and-beta",
    "href": "posts/involute-bevel-gear-part-2/index.html#determination-of-alpha-and-beta",
    "title": "Bevel Tooth Profile (Part 2)",
    "section": "Determination of \\(\\alpha\\) and \\(\\beta\\)",
    "text": "Determination of \\(\\alpha\\) and \\(\\beta\\)\nPreviously, we found the relation to compute the the addendum cone angle: \\[\n\\gamma_f = \\gamma_p + \\tan^{-1}\\left(\\frac {k_a m} {\\rho_1}\\right) = \\gamma_p + \\tan^{-1}\\left(\\frac {2 k_a \\sin(\\gamma_p)} z\\right)\n\\]\nIn other words, \\(\\alpha\\) is the offset angle to \\(\\gamma_p\\): \\[\n\\boxed{\\alpha = \\tan^{-1}\\left(\\frac {k_a m} {\\rho_1}\\right) = \\tan^{-1}\\left(\\frac {2 k_a \\sin(\\gamma_p)} z\\right)}\n\\]\nFor the angle \\(\\beta\\), we have to resort to computations in order to get its value."
  },
  {
    "objectID": "projects.html",
    "href": "projects.html",
    "title": "Different projects",
    "section": "",
    "text": "Mahjong Game\n\n\n\ngame\n\n\n\n\n\n\n\nBenjamin Bourbon\n\n\nOct 23, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nComputation of the sum of prime numbers in different languages\n\n\n\ncomputing\n\n\n\n\n\n\n\nBenjamin Bourbon\n\n\nJan 20, 2023\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/involute-bevel-gear-part-1/index.html",
    "href": "posts/involute-bevel-gear-part-1/index.html",
    "title": "Bevel Tooth Profile (Part 1)",
    "section": "",
    "text": "Bevel gears are designed to transmit mechanical energy between intersecting shafts. However, to design them in a CAD software can be a tough task.\nIn this part, we will see how to compute the involute function of a bevel gear."
  },
  {
    "objectID": "posts/involute-bevel-gear-part-1/index.html#bevel-gear-section",
    "href": "posts/involute-bevel-gear-part-1/index.html#bevel-gear-section",
    "title": "Bevel Tooth Profile (Part 1)",
    "section": "Bevel gear section",
    "text": "Bevel gear section\n\n\n\nFigure 1 : Bevel gear section\n\n\nThere are several fundamental dimensions to know in order to define the involute function :\n\n\n\nVariable\nDescription\n\n\n\n\n\\(m\\)\nthe module\n\n\n\\(z\\)\nthe number of teeth\n\n\n\\(\\alpha\\)\nthe pressure angle\n\n\n\\(k_a\\)\nthe addendum coefficient usually \\(k_a = 1\\)\n\n\n\\(k_f\\)\nthe dedendum coefficient usually \\(k_f = 1.25\\)\n\n\n\\(r_p\\)\nthe pitch radius\n\n\n\\(r_b\\)\nthe base radius\n\n\n\\(\\gamma_p\\)\nthe pitch cone angle\n\n\n\\(\\gamma_b\\)\nthe base cone angle\n\n\n\\(\\gamma_r\\)\nthe addendum cone angle\n\n\n\\(\\gamma_f\\)\nthe dedendum cone angle\n\n\n\\(\\rho_1\\)\nthe external sphere radius\n\n\n\\(\\rho_0\\)\nthe internal sphere radius\n\n\n\nSome relations are already known such as :\n\\[\nr_p = \\frac{m \\cdot z} {2}\n\\]\n\\[\n\\rho_1 = \\frac{2}{3} \\rho_0\n\\]\n\n\n\n\n\n\nTip\n\n\n\nSince the difference between \\(\\rho_1\\) and \\(\\rho_0\\) is equivalent to the tooth depth, its relation can be reworked and adapted with a third parameter which would be the tooth depth. Often, the standard expression is \\(\\rho_0 = \\rho_1 - F_w\\) where \\(F_w\\) is the face width, generally equals to \\(\\frac{1}{3} \\rho_1\\).\n\n\n\nPitch radius\nOn the figure 1, we can easily find a direct relation between \\(\\rho_1\\) and addendum, pitch, base and dedendum radii \\(r\\) with their cone angle \\(\\gamma\\):\n\\[\n\\rho_1 = \\frac{r}{\\sin(\\gamma)}\n\\]\nMore specifically, for the pitch radius \\(r_p\\) and the pitch cone angle \\(\\gamma_p\\), the relation is:\n\\[\n\\boxed{\n    \\rho_1 = \\frac{r_p}{\\sin(\\gamma_p)} = \\frac{m z}{2 \\sin(\\gamma_p)}\n}\n\\]\n\n\nAddendum and dedendum cone angles\nOn the figure 1, the following relations can be found : \\[\n\\gamma_f = \\gamma_p + \\tan^{-1}\\left(\\frac {k_a m} {\\rho_1}\\right) = \\gamma_p + \\tan^{-1}\\left(\\frac {2 k_a \\sin(\\gamma_p)} z\\right)\n\\]\n\\[\n\\gamma_r = \\gamma_p - \\tan^{-1}\\left(\\frac {k_d m} {\\rho_1}\\right) = \\gamma_p - \\tan^{-1}\\left(\\frac {2 k_d \\sin(\\gamma_p)} z\\right)\n\\]\nwhere \\(z\\) is the number of teeth, \\(\\gamma_p\\) is the pitch cone angle, \\(k_a\\) is the addendum coefficient, usually equals to \\(1\\) and \\(k_f\\) is the dedendum coefficient, usually equals ot \\(1.25\\)."
  },
  {
    "objectID": "posts/involute-bevel-gear-part-1/index.html#transmission-and-impact-of-pressure-angle",
    "href": "posts/involute-bevel-gear-part-1/index.html#transmission-and-impact-of-pressure-angle",
    "title": "Bevel Tooth Profile (Part 1)",
    "section": "Transmission and impact of pressure angle",
    "text": "Transmission and impact of pressure angle\nLike spur gears, bevel gears are rolling on an imagined rack which, instead of being a straight, is defined on a sphere. The pitch line of the rack becomes a pitch circle and the radius of this specific circle is the radius of the sphere on which the pinion and the wheel profiles are defined (\\(\\rho_1\\)).\n\n\n\nFigure 2 : Transmission and impact of pressure angle\n\n\nThis figure highlights several paramaters such as the pressure angle \\(\\alpha\\), the pitch cone angle \\(\\gamma_p\\) and the base cone angle \\(\\gamma_b\\). Pinion base circle is colored in green and wheel base circle is colored in red.\nThe pinion and the wheel are constantly in contact on the point \\(P\\) which is the intersection point between pinion pitch circle and wheel pitch circle (not shown on the figure).\n\n\n\n\n\n\nNote\n\n\n\nIn reality, if we would like to be precise, the point of contact would be a straight line with a length of \\(\\rho_1\\) (sphere radius) and formed by the intersection between the pinion pitch cone and the wheel pitch cone. However it can be summarize only by their cone bases.\n\n\nPinion and wheel base circles are in contact on points \\(M_1\\) and \\(M_2\\) respectively with the rotated circle by \\(\\alpha\\).\nThe horizontal circle is the pitch circle of the rack on which both pinion and wheel pitch circles are rolling on.\nOn figure 2, points \\(M_1\\) and \\(M_2\\) are normal to their spherical centers \\(O_1\\) and \\(O_2\\) which means the angles \\(\\widehat{O_1M_1P}\\) and \\(\\widehat{O_2M_2P}\\) are equal to \\(\\pi / 2\\) (i.e. \\(90°\\)).\nAlso the angles \\(\\widehat{O_1PM_1}\\) and \\(\\widehat{O_2PM_2}\\) are equal to \\(\\pi / 2 - \\alpha\\) (i.e. \\(90° - \\alpha\\)).\nBy using the law of sines, we can determine the following relation:\n\\[\n\\frac {\\sin(\\gamma_b)} {\\sin(90° - \\alpha)} = \\frac {\\sin(\\gamma_p)} {\\sin(90°)}\n\\]\nWhich gives us \\[\n\\sin(\\gamma_b) = \\cos(\\alpha) \\sin(\\gamma_p)\n\\]\n\\[\n\\boxed{\\gamma_b = \\sin^{-1}(\\cos(\\alpha) \\sin(\\gamma_p))}\n\\]\nThe more the pressure angle \\(\\alpha\\) increases, the more the base cone angle \\(\\gamma_b\\) increases and the base radius \\(r_b\\) becomes smaller."
  },
  {
    "objectID": "posts/involute-bevel-gear-part-1/index.html#roll-of-spherical-circle-on-base-cone",
    "href": "posts/involute-bevel-gear-part-1/index.html#roll-of-spherical-circle-on-base-cone",
    "title": "Bevel Tooth Profile (Part 1)",
    "section": "Roll of spherical circle on base cone",
    "text": "Roll of spherical circle on base cone\nAs we saw, the base cone is rolling on a sphere circle. It is the same movement by changing view point and saying the base cone is fixed and the sphere circle in rolling around the base cone.\n\n\nVideo\nAnimation : Roll of a spherical circle on the base cone\n\n\nTo find the involute function colored in red, some intermediate parameters must be introduced.\n\n\n\nFigure 3 : Parameters for involute function\n\n\nOn the figure 3, \\(r_b\\) is the base radius and \\(\\rho_1\\) is the sphere radius. Both orange segments have the same length. So the angle of the sphere circle has the value: \\[\n\\phi(t) = \\frac{(t - t_0) \\times r_b}{\\rho_1}\n\\]\nThe involute function is named \\(\\overrightarrow{\\theta(t)}\\) and can be composed with the functions \\(\\overrightarrow{\\gamma(t)}\\), its derivative is \\(\\overrightarrow{\\gamma'(t)}\\) and \\(\\phi(t)\\):\n\\[\n\\overrightarrow{\\theta(t)} = \\rho_1 \\left( \\cos(\\phi(t)) \\frac{\\overrightarrow{\\gamma(t)}}{\\Vert \\overrightarrow{\\gamma(t)} \\Vert} - \\sin(\\phi(t)) \\frac{\\overrightarrow{\\gamma'(t)}}{\\Vert \\overrightarrow{\\gamma'(t)} \\Vert} \\right)\n\\]\nThe function \\(\\overrightarrow{\\gamma(t)}\\) is a point on the base circle positioned on the height \\(\\sqrt{\\rho_1^2 - r_b^2}\\) (Pythagorean theorem). Thus, the function is defined as: \\[\n\\overrightarrow{\\gamma(t)} = \\begin{pmatrix}\n    r_b \\cos(t) \\\\\n    r_b \\sin(t) \\\\\n    \\sqrt{\\rho_1^2 - r_b^2}\n\\end{pmatrix}\n\\]\n\\(\\Vert \\overrightarrow{\\gamma(t)} \\Vert\\) and \\(\\Vert \\overrightarrow{\\gamma'(t)} \\Vert\\) can be computed:\n\\[\n\\begin{align}\n    \\Vert \\overrightarrow{\\gamma(t)} \\Vert & = \\sqrt{(r_b \\cos(t))^2 + (r_b \\sin(t))^2 + \\left(\\sqrt{\\rho_1^2 - r_b^2}\\right)^2} \\\\\n                                           & = \\sqrt{r_b^2 + \\rho_1^2 - r_b^2} \\\\\n                                           & = \\rho_1\n\\end{align}\n\\]\n\\[\n\\begin{align}\n    \\Vert \\overrightarrow{\\gamma'(t)} \\Vert & = \\sqrt{(-r_b \\sin(t))^2 + (r_b \\cos(t))^2} \\\\\n                                           & = \\sqrt{r_b^2} \\\\\n                                           & = r_{b}\n\\end{align}\n\\]\nThus we get the following formula for \\(\\overrightarrow{\\theta(t)}\\): \\[\n\\boxed{\n    \\overrightarrow{\\theta(t)} = \\begin{pmatrix}\n        r_b \\cos(\\phi(t)) \\cos(t) + \\rho_1 \\sin(\\phi(t)) \\sin(t) \\\\\n        r_b \\cos(\\phi(t)) \\sin(t) - \\rho_1 \\sin(\\phi(t)) \\cos(t) \\\\\n        \\sqrt{\\rho_1^2 - r_b^2} \\cos(\\phi(t))\n    \\end{pmatrix}\n}\n\\]\n\nSimplifications\nBy using the relation \\(\\frac{r_b}{\\rho_1} = \\sin(\\gamma_b)\\) and \\(r_b = \\rho_1 \\cdot \\sin(\\gamma_b)\\), the following relations can be simplified: \\[\n\\phi(t) = \\frac{(t - t_0) \\times r_b}{\\rho_1} = \\sin(\\gamma_b) \\cdot (t - t_0)\n\\] \\[\n\\sqrt{\\rho_1^2 - r_b^2} = \\sqrt{\\rho_1^2 \\times (1 - \\sin^2(\\gamma_b))} = \\sqrt{\\rho_1^2 \\times \\cos^2(\\gamma_b)} = \\rho_1 \\cdot \\cos(\\gamma_b)\n\\]\nThus \\(\\overrightarrow{\\theta(t)}\\) becomes: \\[\n\\overrightarrow{\\theta(t)} = \\rho_1 \\cdot \\begin{pmatrix}\n    \\sin(\\gamma_b) \\cos(\\sin(\\gamma_b) \\cdot (t - t_0)) \\cos(t) + \\sin(\\sin(\\gamma_b) \\cdot (t - t_0)) \\sin(t) \\\\\n    \\sin(\\gamma_b) \\cos(\\sin(\\gamma_b) \\cdot (t - t_0)) \\sin(t) - \\sin(\\sin(\\gamma_b) \\cdot (t - t_0)) \\cos(t) \\\\\n    \\cos(\\gamma_b) \\cos(\\sin(\\gamma_b) \\cdot (t - t_0))\n\\end{pmatrix}\n\\]\nBy doing a change of variable \\(t\\) by \\(t + t_0\\) and normalizing \\(\\overrightarrow{\\theta(t)}\\), the involute function of a bevel gear can be written as: \\[\n\\boxed{\n    \\overrightarrow{\\theta(t)} = \\begin{pmatrix}\n        \\sin(\\gamma_b) \\cos(\\sin(\\gamma_b) \\cdot t) \\cos(t + t_0) + \\sin(\\sin(\\gamma_b) \\cdot t) \\sin(t + t_0) \\\\\n        \\sin(\\gamma_b) \\cos(\\sin(\\gamma_b) \\cdot t) \\sin(t + t_0) - \\sin(\\sin(\\gamma_b) \\cdot t) \\cos(t + t_0) \\\\\n        \\cos(\\gamma_b) \\cos(\\sin(\\gamma_b) \\cdot t)\n    \\end{pmatrix}\n}\n\\]"
  },
  {
    "objectID": "posts/introduction-federated-learning/index.html",
    "href": "posts/introduction-federated-learning/index.html",
    "title": "Introduction to Federated Learning",
    "section": "",
    "text": "Federated Learning (FL) was introduced by McMahan et al. (2017) which has attracted increasing interest of ML researchers. They proposed a decentralized collaborative approach that uses multiple devices to train a global model without sharing their local data. In most cases, devices are limited in resources such as computation and communication and restricted by the usage of the user. Federated Learning can meet expectations of specific fields such as natural language processing, computer vision, health care, transportation, finance, smart city, robotics, networking, blockchain and others. In other words, the fact of training a model without exchanging local data gives an overview of new possibilities for taking advantage of each other while keeping privacy.\n\n\n\nFederated Learning (FL) is a method where multiple devices (called clients) are led to collaborate together with communications to a central server in order to train a global model while protecting privacy. In other words, instead of sharing the local data of users, only updates of local models on clients’ devices are communicated to the server.\nFL can be applied in various situations. For instance, in mobile phones there is a large amount of data, which is private by nature. The data could be acquired through GPS locations, microphones or cameras for example. If we want to build a global model such as takes account all contributions of all mobile phones, there are risks and responsibilities to deal with private data. FL aims to build a joint Machine Learning model (ML) without sharing local data. This technique could help diverse fields to collaborate together in order to train a global model that would be used by all participants. For instance, in hospitals, where privacy about health data, is the most important criterion, they could build an organization to perform an ML model in collaboration and every of them would take advantage of each other while keeping privacy. Another way to see FL application is when the implementation of the algorithm is fully decentralized. In other words, when FL architecture is based on peer-to-peer, communications between the server and devices are not required. For example, this approach offers new types of applications such as attack detection model that could be developed jointly by multiple banks.\n\n\n\n\n\nFor this example, we introduce a server and cellphones as the starting point. The server leads communications with cellphones. Cellphones are the requested devices for this example. The goal is to exploit the private data of cellphones without sharing them to the server.\n\n\n\nFigure : A server and several devices\n\n\nNote on the figure, only five devices are represented, but in a real world application, millions of devices could interact with a server (or an infrastructure) in order to apply the Federated Learning.\n\n\n\nAt the beginning of the FL process, a global model is initialized by the server. It can be a neural network or any kind of models (e.g. a decision tree).\n\n\n\nFigure : The server initializes a global neural network\n\n\n\n\n\nThe FL works with rounds where some devices are selected to train the global model on their local data. Every round, devices are selected randomly or arbitrary based on known information about them. The selection part is a crucial part because some devices could be unavailable for a moment or may have different performances of computation and communication (straggler problem). As well, because the private data is not communicated, the distribution of data is managed with difficulty. Also, it might be impraticable if all devices are selected every round.\n\n\n\nFigure : The server selects a sample of devices\n\n\n\n\n\nOnce devices are selected, the server upload the parameters of the global model for all devices.\n\n\nVideo\nAnimation : The server uploads the global neural network to cellphones\n\n\n\n\n\nEach device trains their local model on their private data.\n\n\nVideo\nAnimation : The cellphones train their neural network on local data\n\n\n\n\n\nThe server collects parameters of all local models.\n\n\nVideo\nAnimation : The server downloads the local trained neural networks from cellphones\n\n\n\n\n\nThe local models are aggregated into a new global model. For instance, it can be done by computing the weighted average of the global loss function :\n\\[\nF_g(w) = \\sum_{i = 1}^N \\eta_i F_i(w)\n\\]\nwhere \\(\\eta_i\\) indicates the relative impact of each part of the global model and \\(F_i(w)\\) is the loss function of each dataset \\(D_i\\). For more information, check McMahan et al. (2017).\n\n\nVideo\nAnimation : The server aggregates the local trained neural networks to compute the next global neural network\n\n\n\n\n\nOnce the new global model is computed, the process is restarted until the objective is reached (for instance by maximizing the accuracy).\n\n\nVideo\nAnimation : The process restarts with a new global neural network\n\n\n\n\n\n\n\nVideo\nAnimation : Complete process of Federated Learning\n\n\n\n\n\n\n\nH. B. McMahan, E. Moore, D. Ramage, S. Hampson, and B. A. y. Arcas, “Communication-Efficient Learning of Deep Networks from Decentralized Data,” arXiv:1602.05629 [cs], Feb. 2017, arXiv: 1602.05629. [Online]. Available: http://arxiv.org/abs/1602.05629\nApplication of Reinforcement Learning to improve the selection and the aggregation of Federated Learning (Github)"
  },
  {
    "objectID": "posts/introduction-federated-learning/index.html#introduction",
    "href": "posts/introduction-federated-learning/index.html#introduction",
    "title": "Introduction to Federated Learning",
    "section": "",
    "text": "Federated Learning (FL) was introduced by McMahan et al. (2017) which has attracted increasing interest of ML researchers. They proposed a decentralized collaborative approach that uses multiple devices to train a global model without sharing their local data. In most cases, devices are limited in resources such as computation and communication and restricted by the usage of the user. Federated Learning can meet expectations of specific fields such as natural language processing, computer vision, health care, transportation, finance, smart city, robotics, networking, blockchain and others. In other words, the fact of training a model without exchanging local data gives an overview of new possibilities for taking advantage of each other while keeping privacy."
  },
  {
    "objectID": "posts/introduction-federated-learning/index.html#overview",
    "href": "posts/introduction-federated-learning/index.html#overview",
    "title": "Introduction to Federated Learning",
    "section": "",
    "text": "Federated Learning (FL) is a method where multiple devices (called clients) are led to collaborate together with communications to a central server in order to train a global model while protecting privacy. In other words, instead of sharing the local data of users, only updates of local models on clients’ devices are communicated to the server.\nFL can be applied in various situations. For instance, in mobile phones there is a large amount of data, which is private by nature. The data could be acquired through GPS locations, microphones or cameras for example. If we want to build a global model such as takes account all contributions of all mobile phones, there are risks and responsibilities to deal with private data. FL aims to build a joint Machine Learning model (ML) without sharing local data. This technique could help diverse fields to collaborate together in order to train a global model that would be used by all participants. For instance, in hospitals, where privacy about health data, is the most important criterion, they could build an organization to perform an ML model in collaboration and every of them would take advantage of each other while keeping privacy. Another way to see FL application is when the implementation of the algorithm is fully decentralized. In other words, when FL architecture is based on peer-to-peer, communications between the server and devices are not required. For example, this approach offers new types of applications such as attack detection model that could be developed jointly by multiple banks."
  },
  {
    "objectID": "posts/introduction-federated-learning/index.html#federated-learning-step-by-step",
    "href": "posts/introduction-federated-learning/index.html#federated-learning-step-by-step",
    "title": "Introduction to Federated Learning",
    "section": "",
    "text": "For this example, we introduce a server and cellphones as the starting point. The server leads communications with cellphones. Cellphones are the requested devices for this example. The goal is to exploit the private data of cellphones without sharing them to the server.\n\n\n\nFigure : A server and several devices\n\n\nNote on the figure, only five devices are represented, but in a real world application, millions of devices could interact with a server (or an infrastructure) in order to apply the Federated Learning.\n\n\n\nAt the beginning of the FL process, a global model is initialized by the server. It can be a neural network or any kind of models (e.g. a decision tree).\n\n\n\nFigure : The server initializes a global neural network\n\n\n\n\n\nThe FL works with rounds where some devices are selected to train the global model on their local data. Every round, devices are selected randomly or arbitrary based on known information about them. The selection part is a crucial part because some devices could be unavailable for a moment or may have different performances of computation and communication (straggler problem). As well, because the private data is not communicated, the distribution of data is managed with difficulty. Also, it might be impraticable if all devices are selected every round.\n\n\n\nFigure : The server selects a sample of devices\n\n\n\n\n\nOnce devices are selected, the server upload the parameters of the global model for all devices.\n\n\nVideo\nAnimation : The server uploads the global neural network to cellphones\n\n\n\n\n\nEach device trains their local model on their private data.\n\n\nVideo\nAnimation : The cellphones train their neural network on local data\n\n\n\n\n\nThe server collects parameters of all local models.\n\n\nVideo\nAnimation : The server downloads the local trained neural networks from cellphones\n\n\n\n\n\nThe local models are aggregated into a new global model. For instance, it can be done by computing the weighted average of the global loss function :\n\\[\nF_g(w) = \\sum_{i = 1}^N \\eta_i F_i(w)\n\\]\nwhere \\(\\eta_i\\) indicates the relative impact of each part of the global model and \\(F_i(w)\\) is the loss function of each dataset \\(D_i\\). For more information, check McMahan et al. (2017).\n\n\nVideo\nAnimation : The server aggregates the local trained neural networks to compute the next global neural network\n\n\n\n\n\nOnce the new global model is computed, the process is restarted until the objective is reached (for instance by maximizing the accuracy).\n\n\nVideo\nAnimation : The process restarts with a new global neural network\n\n\n\n\n\n\n\nVideo\nAnimation : Complete process of Federated Learning"
  },
  {
    "objectID": "posts/introduction-federated-learning/index.html#references",
    "href": "posts/introduction-federated-learning/index.html#references",
    "title": "Introduction to Federated Learning",
    "section": "",
    "text": "H. B. McMahan, E. Moore, D. Ramage, S. Hampson, and B. A. y. Arcas, “Communication-Efficient Learning of Deep Networks from Decentralized Data,” arXiv:1602.05629 [cs], Feb. 2017, arXiv: 1602.05629. [Online]. Available: http://arxiv.org/abs/1602.05629\nApplication of Reinforcement Learning to improve the selection and the aggregation of Federated Learning (Github)"
  },
  {
    "objectID": "posts/introduction-spiking-nn/index.html",
    "href": "posts/introduction-spiking-nn/index.html",
    "title": "Introduction to Spiking Neural Networks",
    "section": "",
    "text": "Deep neural networks (DNN) are certainly one of the major advances of the last decades. On one hand, their performance comes from the computation complexity and the energy consumption. On the other hand, SNN offer models with cheaper computation complexity and a budgetary reduction of the energy consumption. SNN bring excellent performances along for task classification such as on images and sound. This network is often found in time series processing with their ability of classification.\n\n\nSNN have a different approach on information transmission from standard neural networks. They try to imitate biological neural networks. Instead of changing the values over time, SNN work on discrete events which are produced in specific moments. They receive peak series as input and produce time series as output.\n\n\n\nFor every time-step, each neuron has some values which are analogous to a electric potential of biological neurons. This value in the neuron can change based on the mathematical model of the neuron. If the value is higher than a threshold, the neuron sends only one impulse for each neuron downstream of it. Finally, the value of the neuron is set under his mean value. After some time, the value of the neuron is back to the mean value.\n\n\nVideo\nAnimation : Impulse of SNN\n\n\n\n\n\nSNN are built on the mathematical descriptions of biological neurons. There are two groups of methods which are used to model SNN :\n\nmodels based on conductance which describe how actions in neurons are initiated and spread\n\nHodgkin-Huxley model\nFitzHugh–Nagumo model\nMorris–Lecar model\nHindmarsh–Rose model\nIzhikevich model\nCable theory\n\nmodels with a threshold which generate a spike for a given threshold\n\nPerfect Integrate-and-fire\nLeaky Integrate-and-fire\nAdaptive Integrate-and-fire"
  },
  {
    "objectID": "posts/introduction-spiking-nn/index.html#what-are-spiking-neural-networks",
    "href": "posts/introduction-spiking-nn/index.html#what-are-spiking-neural-networks",
    "title": "Introduction to Spiking Neural Networks",
    "section": "",
    "text": "SNN have a different approach on information transmission from standard neural networks. They try to imitate biological neural networks. Instead of changing the values over time, SNN work on discrete events which are produced in specific moments. They receive peak series as input and produce time series as output."
  },
  {
    "objectID": "posts/introduction-spiking-nn/index.html#overview-of-spiking-neural-networks",
    "href": "posts/introduction-spiking-nn/index.html#overview-of-spiking-neural-networks",
    "title": "Introduction to Spiking Neural Networks",
    "section": "",
    "text": "For every time-step, each neuron has some values which are analogous to a electric potential of biological neurons. This value in the neuron can change based on the mathematical model of the neuron. If the value is higher than a threshold, the neuron sends only one impulse for each neuron downstream of it. Finally, the value of the neuron is set under his mean value. After some time, the value of the neuron is back to the mean value.\n\n\nVideo\nAnimation : Impulse of SNN"
  },
  {
    "objectID": "posts/introduction-spiking-nn/index.html#several-models",
    "href": "posts/introduction-spiking-nn/index.html#several-models",
    "title": "Introduction to Spiking Neural Networks",
    "section": "",
    "text": "SNN are built on the mathematical descriptions of biological neurons. There are two groups of methods which are used to model SNN :\n\nmodels based on conductance which describe how actions in neurons are initiated and spread\n\nHodgkin-Huxley model\nFitzHugh–Nagumo model\nMorris–Lecar model\nHindmarsh–Rose model\nIzhikevich model\nCable theory\n\nmodels with a threshold which generate a spike for a given threshold\n\nPerfect Integrate-and-fire\nLeaky Integrate-and-fire\nAdaptive Integrate-and-fire"
  },
  {
    "objectID": "posts/introduction-spiking-nn/index.html#case-where-i-ne-0",
    "href": "posts/introduction-spiking-nn/index.html#case-where-i-ne-0",
    "title": "Introduction to Spiking Neural Networks",
    "section": "Case where \\(I \\ne 0\\)",
    "text": "Case where \\(I \\ne 0\\)\n\n\n\nFigure : RC circuit\n\n\nWe apply the Kirchhoff’s current law on the green point : \\[\nI_e = I_{s_1} + I_{s_2}\n\\] We use the characteristic relation of a resistor (Ohm’s law): \\[\nU = RI\n\\]\nAnd the characteristic relation of a capacitor : \\[\nI = C \\times \\frac {dU}{dt}\n\\]\nWe represent the intensity as \\(I(t)\\) and the tension as \\(V_m(t)\\). Thus we get the following relation: \\[\nI(t) = \\frac{V_m(t)}{R_m} + C_m \\frac{dV(m)}{dt}\n\\] \\[\n\\boxed{C_m \\frac{dV(m)}{dt} = I(t) - \\frac{V_m(t)}{R_m}}\n\\]"
  },
  {
    "objectID": "posts/introduction-spiking-nn/index.html#resolution-of-the-differential-equation",
    "href": "posts/introduction-spiking-nn/index.html#resolution-of-the-differential-equation",
    "title": "Introduction to Spiking Neural Networks",
    "section": "Resolution of the differential equation",
    "text": "Resolution of the differential equation\n\nHomogeneous solution\n\\[\n\\frac{dV(m)}{dt} + \\frac{V_m(t)}{R_m C_m} = 0\n\\]\nWe set \\(\\tau = R_m C_m\\). Then we get: \\[\nV_m(t) = A e^{\\frac{-t}{\\tau}}\n\\] where \\(A\\) is the integration constant of the problem.\n\nParticular solution\nWe assume that \\(I(t)\\) is constant. The particular solution has the same form of the second member of the equation. In other words, \\(\\frac{dV(m)}{dt} = 0\\).\n\\[\n\\implies V_m(t) = R_m I(t)\n\\]\n\n\nGeneral solution\n\\[\nV_m(t) = A e^{\\frac{-t}{\\tau}} + R_m I(t)\n\\]\nWe assume that \\(V_m(0^+) = V_m(0^-) = 0\\). Thus, we get: \\[\nA + R_m I = 0 \\iff A = - R_m I\n\\]\nSo:\n\\[\n\\boxed{V_m(t) = R_m I(1 - e^{\\frac{-t}{\\tau}})}\n\\]"
  },
  {
    "objectID": "posts/introduction-spiking-nn/index.html#calculation-of-the-firing-frequency",
    "href": "posts/introduction-spiking-nn/index.html#calculation-of-the-firing-frequency",
    "title": "Introduction to Spiking Neural Networks",
    "section": "Calculation of the firing frequency",
    "text": "Calculation of the firing frequency\nThe model can become more precise by introducing a refractory time in which the neuron can not be discharged. We are interesting to evaluate the frequency when \\(I &gt; I_{th}\\) (when \\(V_m(t)\\) is constant, \\(I_{th} = \\frac{V_{th}}{R_m}\\)): \\[\n\\begin{align}\n         & V_{th} = R_m I(1 - e^{\\frac{-(t - t_{ref})}{\\tau}}) \\\\\n    \\iff & e^{\\frac{-(t - t_{ref})}{\\tau}} = 1 - \\frac{V_{th}}{I R_m} \\\\\n    \\iff & \\frac{-(t - t_{ref})}{\\tau} = \\log{(1 - \\frac{V_{th}}{I R_m})} \\\\\n    \\iff & t = t_{ref} - \\tau \\log{(1 - \\frac{V_{th}}{I R_m})}\n\\end{align}\n\\]\nThen, we can define the firing frequency with the inverse of the total gap between the impulses (including the down-time). The firing frequency is then :\n\\[\n\\boxed{\n    f(I) = \\left\\{\\begin{array}{ll}\n    0, & I \\le I_{th} \\\\\n    \\left[t_{ref} - \\tau \\log{\\left(1 - \\frac{V_{th}}{I R_m}\\right)}\\right]^{-1}, & I &gt; I_{th}\n    \\end{array}\\right.\n}\n\\]\n\nCase where \\(I = 0\\)\n\n\n\nFigure : RC Circuit\n\n\nWe apply the Kirchhoff’s current law on the green point : \\[\nI_{s_1} + I_{s_2} = 0\n\\]\nWe get the following relation : \\[\n\\frac{V_m(t)}{R_m} + C_m \\frac{dV(m)}{dt} = 0\n\\] \\[\n\\boxed{\\frac{dV(m)}{dt} + \\frac{V_m(t)}{\\tau} = 0}\n\\]\nwith \\(\\tau = R_m C_m\\)\n\n\nSolution of the differential equation\n\\[\nV_m(t) = A e^{\\frac{-t}{\\tau}}\n\\]\nwhere \\(A\\) is the integration constant of the problem.\nWe assume \\(V_m(0) = I R_m\\). Thus : \\[\nA = I R_m\n\\]\nWe get then :\n\\[\n\\boxed{V_m(t) = I R_m e^{\\frac{-t}{\\tau}}}\n\\]"
  },
  {
    "objectID": "posts/introduction-spiking-nn/index.html#conclusion",
    "href": "posts/introduction-spiking-nn/index.html#conclusion",
    "title": "Introduction to Spiking Neural Networks",
    "section": "Conclusion",
    "text": "Conclusion\nWe recall that \\(\\tau\\) is characterized of the duration which makes the start-up level to disappear to be replaced by the permanent permanent. The permanent level is reached after several \\(\\tau\\) (\\(\\approx 5 \\tau\\)). We can do the analogy \\(V_m\\), the tension of bounds of the cellular membrane and \\(R_m\\) the membrane resistance.\n\n\n\nImpulse\n\n\nBenefits - the model will not keep an increase of the tension for ever contrary to other models without leak where it is kept until the appearance of a new impulse.\nDrawbacks - the model does not take into account the neuronal adaptation, so that it can not describe spike series."
  },
  {
    "objectID": "posts/introduction-spiking-nn/index.html#architecture-of-a-snn",
    "href": "posts/introduction-spiking-nn/index.html#architecture-of-a-snn",
    "title": "Introduction to Spiking Neural Networks",
    "section": "Architecture of a SNN",
    "text": "Architecture of a SNN\nEven if SNN have an unique concept, they stay a neural network. We can find :\n\nFeedforward Neural Network\nRecurrent Neural Network\nSynfire chain\nReservoir computing"
  },
  {
    "objectID": "posts/introduction-spiking-nn/index.html#spike-timing-dependent-plasticity-stdp",
    "href": "posts/introduction-spiking-nn/index.html#spike-timing-dependent-plasticity-stdp",
    "title": "Introduction to Spiking Neural Networks",
    "section": "Spike-Timing-Dependent Plasticity (STDP)",
    "text": "Spike-Timing-Dependent Plasticity (STDP)\nIt is a unsupervised learning mechanism. The training is realized layer by layer, in other words, the training of the current layer is made when the training of the previous layer is finished. Neurons of the layer compete with each other and those which fire quickly, trigger a STDP and learn from inputs:\n\\[\n\\Delta \\omega_{ij} =\n\\left\\{\n\\begin{array}{c}\na^+ \\omega_{ij}(1 - \\omega_{ij}), & si & t_j - t_i \\le 0 \\\\\na^- \\omega_{ij}(1 - \\omega_{ij}), & si & t_j - t_i &gt; 0\n\\end{array}\n\\right.\n\\] where \\(i\\) and \\(j\\) respectively refer at the index of postsynaptic neurons and presynaptic neurons, \\(t_i\\) and t_j$ are the time related of spikes, \\(\\Delta \\omega_{ij}\\) is the modification of synaptic weights and \\(a^+\\) and \\(a^-\\) are two specific learning rates.\nWe measure the learning convergence of the \\(l\\)-nth layer under the shape :\n\\[\nC_l = \\sum_f \\sum_i \\frac{\\omega_{f,i}(1 - \\omega_{f,i})}{n_\\omega}\n\\]\nwhere \\(C_l\\) tends to \\(0\\) if each of synaptic weights converge to \\(0\\) or \\(1\\). Therefore, we stop the \\(l\\)-nth layer learning when \\(C_l\\) is enough close to \\(0\\) (i.e. \\(C_l &lt; 0.01\\))."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Benjamin Bourbon",
    "section": "",
    "text": "I’m a young engineer with a specialization in High Performance Computing and Artificial Intelligence.\nI develop currently a CAD library pymadcad with a friend.\nThis blog aims to share some personal work which I find useful."
  },
  {
    "objectID": "projects/mahjong/index.html",
    "href": "projects/mahjong/index.html",
    "title": "Mahjong Game",
    "section": "",
    "text": "Mahjong is a puzzle game where the player must find tile pairs. Tile pairs are valid when tiles are separated by a maximum of two shifts.\nFor instance:\n\n\n// Valid paths\n...............\n..#~~~~~#...... // no shift and empty tiles\n...............\n...............\n...............\n\n...............\n..#~~~~~+...... // one shift\n........|......\n........#......\n...............\n\n  +~~~~~~~~~+   // outside the board is allowed\n..|.........|..\n..|.........#.. // two shifts\n..#............\n...............\n...............\n\n\n\n// Invalid paths\n...............\n..#.....#~~+... // three shifts\n..|........|...\n..+~~~~~~~~+...\n...............\n\n...............\n..#............ // no empty tiles\n...............\n..........#....\n...............\n\n\n\nWhere:\n\n# represents targeted tiles\n. represents tiles different from targeted tiles\n  (blank) are empty tiles\n+ represents a shift\n~ and | represents the path which separates targeted tiles\n\n\n\n\nThe games has three levels of difficulty:\n\nNormal : puzzle is easy to solve (solution guaranteed)\nHard: puzzle is hard to solve (solution guaranteed)\nImpossible (random) (solution not guaranteed)\n\nThe player can go back until maximum 10 steps (previous moves are kept in memory).\nThe player has a maximum of 10 hints during a game, where each hint gives him a valid move to play.\nThe player can save the game into a file and load a game from a file (files do not need specific suffix).\n\n\n\n.\n├── assets                              // assets for `README.md`\n├── LICENSE\n├── pom.xml                             // Maven project description\n├── README.md\n└── src\n    ├── main\n    │   └── java\n    │       ├── game                    // Game files\n    │       │   ├── Board.java          // Set of methods for generating a board\n    │       │   ├── Game.java           // Set of methods for game rules\n    │       │   ├── Solver.java         // Set of methods to solve a board\n    │       │   ├── Tile.java           // Set of methods for manipulating a tile\n    │       │   └── Vec2D.java          // 2D vector\n    │       └── ui                      // User Interface files\n    │           ├── GUI.java            // Graphical User Interface\n    │           └── TUI.java            // Text User Interface\n    └── test\n        └── java\n            └── game\n                ├── TileTest.java\n                └── Vec2DTest.java\nIn game/Board.java:\n\ngenerateSolvableStaticLine() is based on line methods\ngenerateSolvableStatic() generates a random solvable board. Broadly speaking, it tries to solve the board by fixing it when it is not.\n\nIn game/Solver.java:\n\nnextMerge finds and returns a pair of coordinates to play a valid move. This method is the core of Solver and it calls other methods.\n\nIn game/Tile.java:\n\nall() allows to generate an array of all tile types\nnumber() allows to generate a array of disponibilities by tile type\n\n\n\n\n\n\nWe want to verify if a path exists between two tiles. First and foremost, we check if two tiles can be paired; if it’s the case, we continue the program, else we returns false (see Solver.validMerge(Vec2D a, Vec2D b)):\npublic boolean validMerge(Vec2D a, Vec2D b) {\n    // Checks if the tiles are equivalent\n    if (!this.getCell(a).isPair(this.getCell(b))) {\n        return false;\n    }\n    \n    // continue the program\n}\nIn a second phase, an array sides contain all directions and an array path will keep the borrowed path over iterations. The path begins with the vector a. If the vector b is found in the closest neighbors (defined by directions in sides), it returns true else the program continues.\n// Possible directions\nVec2D sides[] = Board.sides();\n\n// Path taken to reach to the current step. It works like a stack.\n// Array of directions taken to reach to each step\nArrayList&lt;Integer&gt; path = new ArrayList&lt;&gt;();\n\n\n// Variables of the current step\nint side = 0;   // Testing direction\nVec2D pos = a;  // Current position\nint shifts = 0; // Number of shifts in the current path\nNow, it starts with a direction and a path of empty cells is stacked until a deadlock or the destination is found, in which case, the program is finished. The direction is changed if we want an empty cell side by side the actual position of the program.\nwhile (true) {\n    boolean noSideFound = true;\n\n    // Checks if B is in the nearest neighbors\n    for (int i = side; i &lt; sides.length; i++) {\n        Vec2D next = pos.add(sides[i]);\n        int lastdir = path.size() - 1;\n        if (\n            next.equals(b) && (\n                shifts &lt; 2 || (shifts &lt;= 2 && lastdir &gt;= 0 && i == path.get(lastdir))\n            )\n        ) {\n            return true;\n        }\n    }\n\n    for (; side &lt; sides.length; side++) {\n        Vec2D next = pos.add(sides[side]);\n        int max = this.SIZE + 1;\n        if (next.x &gt; max || next.y &gt; max || next.x &lt; 0 || next.y &lt; 0) {\n            continue;\n        }\n\n        Tile t = this.getCell(next);\n        if (t.isFree()) {\n            if (shifts &lt; 2 || (path.size() &gt; 0 && side == path.get(path.size() - 1))) {\n                // Count the shift\n                if (path.size() &gt; 0 && side != path.get(path.size() - 1)) {\n                    shifts++;\n                }\n                // Stacks the new direction\n                path.add(side);\n                pos = next;\n                side = 0;\n                noSideFound = false;\n                break;\n            }\n        }\n    }\n\n    // ...\n}\nOtherwise, the path is unstacked until an empty cell, with more than one empty neighbor, is found. A new direction is then defined and chosen. It is repeated until the last step but in a new direction.\nwhile (true) {\n    // ...\n\n    if (noSideFound) {\n        do {\n            if (path.size() &lt;= 0) {\n                return false;\n            } // If the path is empty, there is no possible path\n            // Unstacks the path\n            int last = path.size() - 1;\n            side = path.get(last);\n            pos = pos.sub(sides[side]);\n            path.remove(last);\n            // Uncounts the shift\n            if (path.size() &gt; 0 && side != path.get(path.size() - 1)) {\n                shifts--;\n            }\n\n            side++; // Checks if the next side\n        } while (side &gt;= sides.length);\n    }\n}\nBy following these process, all possible paths are checked and a path with a maximum of two shifts can be found if exists.\n\n\n\nWhen I was wondering if it is possible to make a solvable generation but also random, two ideas came to my mind.\nThe first one is simple: progress in the resolution of the board until reaching a step where there are no possible next move and then managing the last tiles in order to be able to continue the resolution. For that, some automatic resolution functions must exist.\n\n\n\nTiles cannot be paired: by starting with the cell in orange, the second cell in blue\n\n\n\nAfter swapping cells, there is a new possible move and the resolution can continue.\n\n\nAt the same time, each tile swap is taken back to the initial board. The tiles which are not paired together stay always at the same position during the resolution (no tile fall by gravity). The tiles, which were swapped, do not make the board solvable at this step.\nWhen the resolution is finished, the board is solvable.\n\n\n\n\n\n\nNote\n\n\n\ngenerateSolvableStatic() follows these steps and is based on Solver.nextMerge() to move forward the resolution.\n\n\n\n\n\nThis method is the second one, designed to be faster for generation. It creates easier boards to solve.\nThis method involves to place two tiles in order to be aligned. They are going to be the board base. Then, for each new placed tile, it must be placed with a tile already placed and its pair will be placed on the same straight line in relation to the first tile and near an already placed tile.\n\n\n\nIn this example, there are orange tiles, blue tiles and green tiles. By iterating in this manner, it is guaranteed that a solution exists when the board is completely generated.\n\n\n\n\n\n\nNote\n\n\n\nWhen the board is generated, there are some chances to finish in a specific case where there are only two cells to complete. The generation must be restarted until a complete board is found.\n\n\n\n\n\n\nHere is the set of methods for generating a board. generateStaticLine() is the main method. generateFirstDirection(Vec2D pos) allows to generate randomly a new direction. If pos is in a corner, two directions are possible, if pos is on a border, three directions are possible, if pos is in the middle of the board, four directions are possible. generatingFirstMovement(Vec2D, pos, int direction) allows to find the position of a tile pair in a random manner given the specified direction in relation with the position of the initial tile.\n// Build a board with the line method\npublic void generateSolvableStaticLine() { ... }\n\n// Here, all methods are linked to generateStaticLine\n// Generates a random direction (the first one)\nint generatingFirstDirection(Vec2D pos) { ... }\n\n// Generates a random position given the specified direction (the first one)\nVec2D generatingFirstMovement(Vec2D pos, int direction) { ... }\n\n// Useful for the second placed tile\n// Method to distinguish between \"generic\" tiles and unique ones\n// If generic tile: unmodified index\n// If unique tile: returns the index of the same *family* and yet available\nint disponibilities(int index, int[] dispo) { ... }\n\n// Returns the opposite direction\nint opposedDirection(int direction) { ... }\n\n// Returns true if filled cells around the (non-empty) position exist\nboolean checkingAroundCase(Vec2D pos, int direction) { ... }\n\n// Generates a distance on which we search a position of the second tile\nArrayList&lt;Integer&gt; generatingDistance(Vec2D pos, int direction) { ... }\n\n// Generates a position which checks the line method\nint[] generatingNewPosition(ArrayList&lt;Vec2D&gt; insert) { ... }\n\n// Generates a \"filled\" direction on the specified position\nint generatingNewDirection(Vec2D pos) { ... }\n\n// Generates a pair position given a specified direction and a specified position\nVec2D generatingEvenPosition(Vec2D pos, int direction) { ... }\n\n// Returns the direction array directly accessible from a cell\npublic static Vec2D[] sides() { ... }\ndisponibilities(int index, int[] dispo) returns an index. Since in the game, there are tiles which are available in an unique manner, and tiles which are four times available, this method evaluates if when a season or a flower (first placed tile) is placed, then its pair will be anoter flower or season*.\nopposedDirection(int direction) returns the opposite direction of the specified argument.\ncheckingAroundCase(Vec2D pos, int direction) checks if some filled cells exist around the position pos.\ngeneratingDistance(Vec2D pos, int direction) generates a distance given the specified direction and the position pos. In other words, for a position \\((x, y)\\) and a direction, the tested positions approach the border or are futher the border.\ngeneratingNewPosition(ArrayList&lt;Vec2D&gt; insert) is a method which chooses randomly a already placed tile and checks if there is an empty tile around this tile. In an empty tile is found, it checks if a direction exists where the tile will be placed.\ngeneratingNewDirection(Vec2D pos) allows to find a random direction which guarantees that:\n\nan empty cell exists or an cell is placed where the future tile pair should be (which is not on the border)\nif an empty cell exists, it must be placed side by sibe with a filled cell\n\ngeneratingEvenPosition(Vec2D pos, int direction) returns the coordinates (Vec2D) of the tile pair, knowing that it is chosen randomly and placement criteria are guaranteed.\n\n\n\nThe solver allows to generate a board, to test generated boards and game rules. In fact, it is hard to solve correctly a board if the rules are wrong or incomplete.\nThe solver is used moveover for the generation of hints during a game. It is the through itself that a game runs through, event in the GUI.\nThe most useful method is nextMerge(). It works according two modes:\n\nnextMergeNear : simple iteration over the board to find a pair of adjacente tiles\nnextMergeDistant : slow method which searchs a pair of adjacente tiles or not. For every tile on the board, it searchs its pairs and tests the paths between each tile and the pair in question.\n\nOther algorithms were tested but were less optimized in the end if we considered the complexity of access number of the board.\nTo solve a board from zero, it is enough, in almost all cases, to apply systematically the suggested move by the solver until there is no tile on the board.\n\n\n\nMahjong Game - Source Code"
  },
  {
    "objectID": "projects/mahjong/index.html#goal",
    "href": "projects/mahjong/index.html#goal",
    "title": "Mahjong Game",
    "section": "",
    "text": "Mahjong is a puzzle game where the player must find tile pairs. Tile pairs are valid when tiles are separated by a maximum of two shifts.\nFor instance:\n\n\n// Valid paths\n...............\n..#~~~~~#...... // no shift and empty tiles\n...............\n...............\n...............\n\n...............\n..#~~~~~+...... // one shift\n........|......\n........#......\n...............\n\n  +~~~~~~~~~+   // outside the board is allowed\n..|.........|..\n..|.........#.. // two shifts\n..#............\n...............\n...............\n\n\n\n// Invalid paths\n...............\n..#.....#~~+... // three shifts\n..|........|...\n..+~~~~~~~~+...\n...............\n\n...............\n..#............ // no empty tiles\n...............\n..........#....\n...............\n\n\n\nWhere:\n\n# represents targeted tiles\n. represents tiles different from targeted tiles\n  (blank) are empty tiles\n+ represents a shift\n~ and | represents the path which separates targeted tiles"
  },
  {
    "objectID": "projects/mahjong/index.html#game-specifications",
    "href": "projects/mahjong/index.html#game-specifications",
    "title": "Mahjong Game",
    "section": "",
    "text": "The games has three levels of difficulty:\n\nNormal : puzzle is easy to solve (solution guaranteed)\nHard: puzzle is hard to solve (solution guaranteed)\nImpossible (random) (solution not guaranteed)\n\nThe player can go back until maximum 10 steps (previous moves are kept in memory).\nThe player has a maximum of 10 hints during a game, where each hint gives him a valid move to play.\nThe player can save the game into a file and load a game from a file (files do not need specific suffix)."
  },
  {
    "objectID": "projects/mahjong/index.html#game-structure",
    "href": "projects/mahjong/index.html#game-structure",
    "title": "Mahjong Game",
    "section": "",
    "text": ".\n├── assets                              // assets for `README.md`\n├── LICENSE\n├── pom.xml                             // Maven project description\n├── README.md\n└── src\n    ├── main\n    │   └── java\n    │       ├── game                    // Game files\n    │       │   ├── Board.java          // Set of methods for generating a board\n    │       │   ├── Game.java           // Set of methods for game rules\n    │       │   ├── Solver.java         // Set of methods to solve a board\n    │       │   ├── Tile.java           // Set of methods for manipulating a tile\n    │       │   └── Vec2D.java          // 2D vector\n    │       └── ui                      // User Interface files\n    │           ├── GUI.java            // Graphical User Interface\n    │           └── TUI.java            // Text User Interface\n    └── test\n        └── java\n            └── game\n                ├── TileTest.java\n                └── Vec2DTest.java\nIn game/Board.java:\n\ngenerateSolvableStaticLine() is based on line methods\ngenerateSolvableStatic() generates a random solvable board. Broadly speaking, it tries to solve the board by fixing it when it is not.\n\nIn game/Solver.java:\n\nnextMerge finds and returns a pair of coordinates to play a valid move. This method is the core of Solver and it calls other methods.\n\nIn game/Tile.java:\n\nall() allows to generate an array of all tile types\nnumber() allows to generate a array of disponibilities by tile type"
  },
  {
    "objectID": "projects/mahjong/index.html#more-details",
    "href": "projects/mahjong/index.html#more-details",
    "title": "Mahjong Game",
    "section": "",
    "text": "We want to verify if a path exists between two tiles. First and foremost, we check if two tiles can be paired; if it’s the case, we continue the program, else we returns false (see Solver.validMerge(Vec2D a, Vec2D b)):\npublic boolean validMerge(Vec2D a, Vec2D b) {\n    // Checks if the tiles are equivalent\n    if (!this.getCell(a).isPair(this.getCell(b))) {\n        return false;\n    }\n    \n    // continue the program\n}\nIn a second phase, an array sides contain all directions and an array path will keep the borrowed path over iterations. The path begins with the vector a. If the vector b is found in the closest neighbors (defined by directions in sides), it returns true else the program continues.\n// Possible directions\nVec2D sides[] = Board.sides();\n\n// Path taken to reach to the current step. It works like a stack.\n// Array of directions taken to reach to each step\nArrayList&lt;Integer&gt; path = new ArrayList&lt;&gt;();\n\n\n// Variables of the current step\nint side = 0;   // Testing direction\nVec2D pos = a;  // Current position\nint shifts = 0; // Number of shifts in the current path\nNow, it starts with a direction and a path of empty cells is stacked until a deadlock or the destination is found, in which case, the program is finished. The direction is changed if we want an empty cell side by side the actual position of the program.\nwhile (true) {\n    boolean noSideFound = true;\n\n    // Checks if B is in the nearest neighbors\n    for (int i = side; i &lt; sides.length; i++) {\n        Vec2D next = pos.add(sides[i]);\n        int lastdir = path.size() - 1;\n        if (\n            next.equals(b) && (\n                shifts &lt; 2 || (shifts &lt;= 2 && lastdir &gt;= 0 && i == path.get(lastdir))\n            )\n        ) {\n            return true;\n        }\n    }\n\n    for (; side &lt; sides.length; side++) {\n        Vec2D next = pos.add(sides[side]);\n        int max = this.SIZE + 1;\n        if (next.x &gt; max || next.y &gt; max || next.x &lt; 0 || next.y &lt; 0) {\n            continue;\n        }\n\n        Tile t = this.getCell(next);\n        if (t.isFree()) {\n            if (shifts &lt; 2 || (path.size() &gt; 0 && side == path.get(path.size() - 1))) {\n                // Count the shift\n                if (path.size() &gt; 0 && side != path.get(path.size() - 1)) {\n                    shifts++;\n                }\n                // Stacks the new direction\n                path.add(side);\n                pos = next;\n                side = 0;\n                noSideFound = false;\n                break;\n            }\n        }\n    }\n\n    // ...\n}\nOtherwise, the path is unstacked until an empty cell, with more than one empty neighbor, is found. A new direction is then defined and chosen. It is repeated until the last step but in a new direction.\nwhile (true) {\n    // ...\n\n    if (noSideFound) {\n        do {\n            if (path.size() &lt;= 0) {\n                return false;\n            } // If the path is empty, there is no possible path\n            // Unstacks the path\n            int last = path.size() - 1;\n            side = path.get(last);\n            pos = pos.sub(sides[side]);\n            path.remove(last);\n            // Uncounts the shift\n            if (path.size() &gt; 0 && side != path.get(path.size() - 1)) {\n                shifts--;\n            }\n\n            side++; // Checks if the next side\n        } while (side &gt;= sides.length);\n    }\n}\nBy following these process, all possible paths are checked and a path with a maximum of two shifts can be found if exists.\n\n\n\nWhen I was wondering if it is possible to make a solvable generation but also random, two ideas came to my mind.\nThe first one is simple: progress in the resolution of the board until reaching a step where there are no possible next move and then managing the last tiles in order to be able to continue the resolution. For that, some automatic resolution functions must exist.\n\n\n\nTiles cannot be paired: by starting with the cell in orange, the second cell in blue\n\n\n\nAfter swapping cells, there is a new possible move and the resolution can continue.\n\n\nAt the same time, each tile swap is taken back to the initial board. The tiles which are not paired together stay always at the same position during the resolution (no tile fall by gravity). The tiles, which were swapped, do not make the board solvable at this step.\nWhen the resolution is finished, the board is solvable.\n\n\n\n\n\n\nNote\n\n\n\ngenerateSolvableStatic() follows these steps and is based on Solver.nextMerge() to move forward the resolution.\n\n\n\n\n\nThis method is the second one, designed to be faster for generation. It creates easier boards to solve.\nThis method involves to place two tiles in order to be aligned. They are going to be the board base. Then, for each new placed tile, it must be placed with a tile already placed and its pair will be placed on the same straight line in relation to the first tile and near an already placed tile.\n\n\n\nIn this example, there are orange tiles, blue tiles and green tiles. By iterating in this manner, it is guaranteed that a solution exists when the board is completely generated.\n\n\n\n\n\n\nNote\n\n\n\nWhen the board is generated, there are some chances to finish in a specific case where there are only two cells to complete. The generation must be restarted until a complete board is found."
  },
  {
    "objectID": "projects/mahjong/index.html#set-of-methods",
    "href": "projects/mahjong/index.html#set-of-methods",
    "title": "Mahjong Game",
    "section": "",
    "text": "Here is the set of methods for generating a board. generateStaticLine() is the main method. generateFirstDirection(Vec2D pos) allows to generate randomly a new direction. If pos is in a corner, two directions are possible, if pos is on a border, three directions are possible, if pos is in the middle of the board, four directions are possible. generatingFirstMovement(Vec2D, pos, int direction) allows to find the position of a tile pair in a random manner given the specified direction in relation with the position of the initial tile.\n// Build a board with the line method\npublic void generateSolvableStaticLine() { ... }\n\n// Here, all methods are linked to generateStaticLine\n// Generates a random direction (the first one)\nint generatingFirstDirection(Vec2D pos) { ... }\n\n// Generates a random position given the specified direction (the first one)\nVec2D generatingFirstMovement(Vec2D pos, int direction) { ... }\n\n// Useful for the second placed tile\n// Method to distinguish between \"generic\" tiles and unique ones\n// If generic tile: unmodified index\n// If unique tile: returns the index of the same *family* and yet available\nint disponibilities(int index, int[] dispo) { ... }\n\n// Returns the opposite direction\nint opposedDirection(int direction) { ... }\n\n// Returns true if filled cells around the (non-empty) position exist\nboolean checkingAroundCase(Vec2D pos, int direction) { ... }\n\n// Generates a distance on which we search a position of the second tile\nArrayList&lt;Integer&gt; generatingDistance(Vec2D pos, int direction) { ... }\n\n// Generates a position which checks the line method\nint[] generatingNewPosition(ArrayList&lt;Vec2D&gt; insert) { ... }\n\n// Generates a \"filled\" direction on the specified position\nint generatingNewDirection(Vec2D pos) { ... }\n\n// Generates a pair position given a specified direction and a specified position\nVec2D generatingEvenPosition(Vec2D pos, int direction) { ... }\n\n// Returns the direction array directly accessible from a cell\npublic static Vec2D[] sides() { ... }\ndisponibilities(int index, int[] dispo) returns an index. Since in the game, there are tiles which are available in an unique manner, and tiles which are four times available, this method evaluates if when a season or a flower (first placed tile) is placed, then its pair will be anoter flower or season*.\nopposedDirection(int direction) returns the opposite direction of the specified argument.\ncheckingAroundCase(Vec2D pos, int direction) checks if some filled cells exist around the position pos.\ngeneratingDistance(Vec2D pos, int direction) generates a distance given the specified direction and the position pos. In other words, for a position \\((x, y)\\) and a direction, the tested positions approach the border or are futher the border.\ngeneratingNewPosition(ArrayList&lt;Vec2D&gt; insert) is a method which chooses randomly a already placed tile and checks if there is an empty tile around this tile. In an empty tile is found, it checks if a direction exists where the tile will be placed.\ngeneratingNewDirection(Vec2D pos) allows to find a random direction which guarantees that:\n\nan empty cell exists or an cell is placed where the future tile pair should be (which is not on the border)\nif an empty cell exists, it must be placed side by sibe with a filled cell\n\ngeneratingEvenPosition(Vec2D pos, int direction) returns the coordinates (Vec2D) of the tile pair, knowing that it is chosen randomly and placement criteria are guaranteed."
  },
  {
    "objectID": "projects/mahjong/index.html#solver-explanation",
    "href": "projects/mahjong/index.html#solver-explanation",
    "title": "Mahjong Game",
    "section": "",
    "text": "The solver allows to generate a board, to test generated boards and game rules. In fact, it is hard to solve correctly a board if the rules are wrong or incomplete.\nThe solver is used moveover for the generation of hints during a game. It is the through itself that a game runs through, event in the GUI.\nThe most useful method is nextMerge(). It works according two modes:\n\nnextMergeNear : simple iteration over the board to find a pair of adjacente tiles\nnextMergeDistant : slow method which searchs a pair of adjacente tiles or not. For every tile on the board, it searchs its pairs and tests the paths between each tile and the pair in question.\n\nOther algorithms were tested but were less optimized in the end if we considered the complexity of access number of the board.\nTo solve a board from zero, it is enough, in almost all cases, to apply systematically the suggested move by the solver until there is no tile on the board."
  },
  {
    "objectID": "projects/mahjong/index.html#references",
    "href": "projects/mahjong/index.html#references",
    "title": "Mahjong Game",
    "section": "",
    "text": "Mahjong Game - Source Code"
  }
]